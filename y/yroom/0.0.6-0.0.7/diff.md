# Comparing `tmp/yroom-0.0.6.tar.gz` & `tmp/yroom-0.0.7.tar.gz`

## Comparing `yroom-0.0.6.tar` & `yroom-0.0.7.tar`

### file list

```diff
@@ -1,14 +1,14 @@
--rw-r--r--   0        0        0      315 1970-01-01 00:00:00.000000 yroom-0.0.6/Cargo.toml
--rw-r--r--   0     1001      123     2772 2023-05-03 20:26:57.000000 yroom-0.0.6/.github/workflows/release.yml
--rw-r--r--   0     1001      123     1174 2023-05-03 20:26:57.000000 yroom-0.0.6/.github/workflows/test.yml
--rw-r--r--   0     1001      123       40 2023-05-03 20:26:57.000000 yroom-0.0.6/.gitignore
--rw-r--r--   0     1001      123     1083 2023-05-03 20:26:57.000000 yroom-0.0.6/LICENSE
--rw-r--r--   0     1001      123      442 2023-05-03 20:26:57.000000 yroom-0.0.6/README.md
--rw-r--r--   0     1001      123       10 2023-05-03 20:28:07.000000 yroom-0.0.6/dist/yroom-0.0.6.tar.gz
--rw-r--r--   0     1001      123      746 2023-05-03 20:26:57.000000 yroom-0.0.6/pyproject.toml
--rw-r--r--   0     1001      123      272 2023-05-03 20:26:57.000000 yroom-0.0.6/src/lib.rs
--rw-r--r--   0     1001      123    21745 2023-05-03 20:26:57.000000 yroom-0.0.6/src/roomsync.rs
--rw-r--r--   0     1001      123     6507 2023-05-03 20:26:57.000000 yroom-0.0.6/tests/test_yroom.py
--rw-r--r--   0     1001      123     3889 2023-05-03 20:26:57.000000 yroom-0.0.6/yroom.pyi
--rw-r--r--   0     1001      123    13697 2023-05-03 20:26:57.000000 yroom-0.0.6/Cargo.lock
--rw-r--r--   0        0        0     1030 1970-01-01 00:00:00.000000 yroom-0.0.6/PKG-INFO
+-rw-r--r--   0        0        0      315 1970-01-01 00:00:00.000000 yroom-0.0.7/Cargo.toml
+-rw-r--r--   0     1001      123     2786 2023-05-15 19:06:37.000000 yroom-0.0.7/.github/workflows/release.yml
+-rw-r--r--   0     1001      123     1174 2023-05-15 19:06:37.000000 yroom-0.0.7/.github/workflows/test.yml
+-rw-r--r--   0     1001      123       40 2023-05-15 19:06:37.000000 yroom-0.0.7/.gitignore
+-rw-r--r--   0     1001      123     1083 2023-05-15 19:06:37.000000 yroom-0.0.7/LICENSE
+-rw-r--r--   0     1001      123      442 2023-05-15 19:06:37.000000 yroom-0.0.7/README.md
+-rw-r--r--   0     1001      123       10 2023-05-15 19:08:09.000000 yroom-0.0.7/dist/yroom-0.0.7.tar.gz
+-rw-r--r--   0     1001      123      746 2023-05-15 19:06:37.000000 yroom-0.0.7/pyproject.toml
+-rw-r--r--   0     1001      123      272 2023-05-15 19:06:37.000000 yroom-0.0.7/src/lib.rs
+-rw-r--r--   0     1001      123    24523 2023-05-15 19:06:37.000000 yroom-0.0.7/src/roomsync.rs
+-rw-r--r--   0     1001      123     6639 2023-05-15 19:06:37.000000 yroom-0.0.7/tests/test_yroom.py
+-rw-r--r--   0     1001      123     3903 2023-05-15 19:06:37.000000 yroom-0.0.7/yroom.pyi
+-rw-r--r--   0     1001      123    13697 2023-05-15 19:06:37.000000 yroom-0.0.7/Cargo.lock
+-rw-r--r--   0        0        0     1030 1970-01-01 00:00:00.000000 yroom-0.0.7/PKG-INFO
```

### Comparing `yroom-0.0.6/.github/workflows/release.yml` & `yroom-0.0.7/.github/workflows/release.yml`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 # This file is autogenerated by maturin v0.14.15
 # To update, run
 #
 #    maturin generate-ci github
 #
+name: Release
 on:
   push:
     tags:
       - 'v*' # Push events to matching v*, i.e. v1.0, v20.15.10
 
 permissions:
   contents: read
```

### Comparing `yroom-0.0.6/.github/workflows/test.yml` & `yroom-0.0.7/.github/workflows/test.yml`

 * *Files identical despite different names*

### Comparing `yroom-0.0.6/LICENSE` & `yroom-0.0.7/LICENSE`

 * *Files identical despite different names*

### Comparing `yroom-0.0.6/pyproject.toml` & `yroom-0.0.7/pyproject.toml`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 [build-system]
 requires = ["maturin>=0.14,<0.15"]
 build-backend = "maturin"
 
 [project]
 name = "yroom"
-version = "0.0.6"
+version = "0.0.7"
 requires-python = ">=3.7"
 description = "Yjs sync and awareness protocol handler for a non-editing client (e.g. server)"
 authors = [
     { name = "Stefan Wehrmeyer", email = "mail@stefanwehrmeyer.com" }
 ]
 classifiers = [
     "Programming Language :: Rust",
```

### Comparing `yroom-0.0.6/src/roomsync.rs` & `yroom-0.0.7/src/roomsync.rs`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 use std::{
     collections::{HashMap, HashSet},
     sync::{Arc, Mutex},
 };
 
 use pyo3::{
     prelude::*,
-    types::{PyBytes, PyDict},
+    types::{PyBytes, PyDict, PyList},
 };
 
 use lib0::{
     decoding::{Cursor, Read},
     encoding::Write,
 };
 use y_sync::{
@@ -32,54 +32,88 @@
     V2,
 }
 
 struct EncoderWrapper {
     protocol_version: ProtocolVersion,
     messages: Vec<Message>,
     prefix: Option<String>,
+    disable_pipelining: bool,
 }
 
 impl EncoderWrapper {
-    fn new(protocol_version: &ProtocolVersion, prefix: Option<String>) -> Self {
+    fn new(
+        protocol_version: &ProtocolVersion,
+        disable_pipelining: bool,
+        prefix: Option<String>,
+    ) -> Self {
         EncoderWrapper {
             protocol_version: protocol_version.clone(),
             messages: Vec::default(),
             prefix,
+            disable_pipelining,
         }
     }
     fn push(&mut self, message: Message) {
         self.messages.push(message);
     }
-    fn to_vec(&self) -> Vec<u8> {
+    fn to_vecs(&self) -> Vec<Vec<u8>> {
         match self.protocol_version {
             ProtocolVersion::V1 => {
                 if self.messages.is_empty() {
                     return Vec::new();
                 }
-                let mut encoder = EncoderV1::new();
-                if let Some(prefix) = &self.prefix {
-                    encoder.write_string(prefix);
+                if self.disable_pipelining {
+                    self.messages
+                        .iter()
+                        .map(|message| {
+                            let mut encoder = EncoderV1::new();
+                            if let Some(prefix) = &self.prefix {
+                                encoder.write_string(prefix);
+                            }
+                            message.encode(&mut encoder);
+                            encoder.to_vec()
+                        })
+                        .collect()
+                } else {
+                    let mut encoder = EncoderV1::new();
+                    if let Some(prefix) = &self.prefix {
+                        encoder.write_string(prefix);
+                    }
+                    self.messages.iter().for_each(|message| {
+                        message.encode(&mut encoder);
+                    });
+                    vec![encoder.to_vec()]
                 }
-                self.messages.iter().for_each(|message| {
-                    message.encode(&mut encoder);
-                });
-                encoder.to_vec()
             }
             ProtocolVersion::V2 => {
                 if self.messages.is_empty() {
                     return Vec::new();
                 }
-                let mut encoder = EncoderV2::new();
-                if let Some(prefix) = &self.prefix {
-                    encoder.write_string(prefix);
+                if self.disable_pipelining {
+                    self.messages
+                        .iter()
+                        .map(|message| {
+                            let mut encoder = EncoderV2::new();
+                            if let Some(prefix) = &self.prefix {
+                                encoder.write_string(prefix);
+                            }
+                            message.encode(&mut encoder);
+                            encoder.to_vec()
+                        })
+                        .collect()
+                } else {
+                    let mut encoder = EncoderV2::new();
+                    if let Some(prefix) = &self.prefix {
+                        encoder.write_string(prefix);
+                    }
+                    self.messages.iter().for_each(|message| {
+                        message.encode(&mut encoder);
+                    });
+                    vec![encoder.to_vec()]
                 }
-                self.messages.iter().for_each(|message| {
-                    message.encode(&mut encoder);
-                });
-                encoder.to_vec()
             }
         }
     }
 }
 
 struct DecoderWrapper<'a> {
     protocol_version: ProtocolVersion,
@@ -148,22 +182,24 @@
 }
 
 #[derive(Clone, Debug)]
 struct YRoomSettings {
     pub protocol_version: ProtocolVersion,
     pub name_prefix: bool,
     pub server_start_sync: bool,
+    pub disable_pipelining: bool,
 }
 
 impl Default for YRoomSettings {
     fn default() -> Self {
         YRoomSettings {
             protocol_version: ProtocolVersion::V1,
             name_prefix: false,
             server_start_sync: true,
+            disable_pipelining: false,
         }
     }
 }
 
 impl FromPyObject<'_> for YRoomSettings {
     fn extract(ob: &PyAny) -> PyResult<Self> {
         let settings = ob.downcast::<PyDict>()?;
@@ -176,37 +212,60 @@
             Some(name_prefix) => name_prefix.extract::<bool>()?,
             None => false,
         };
         let server_start_sync = match settings.get_item("SERVER_START_SYNC") {
             Some(server_start_sync) => server_start_sync.extract::<bool>()?,
             None => true,
         };
-
+        let disable_pipelining = match settings.get_item("PROTOCOL_DISABLE_PIPELINING") {
+            Some(disable_pipelining) => disable_pipelining.extract::<bool>()?,
+            None => false,
+        };
         Ok(YRoomSettings {
             protocol_version,
             name_prefix,
             server_start_sync,
+            disable_pipelining,
         })
     }
 }
 
 #[pyclass]
 pub struct YRoomMessage {
     #[pyo3(get)]
-    pub payload: PyObject,
+    pub payloads: PyObject,
     #[pyo3(get)]
-    pub broadcast_payload: PyObject,
+    pub broadcast_payloads: PyObject,
+}
+
+fn make_payloads(py: Python, payloads: &[Vec<u8>]) -> PyObject {
+    PyList::new(py, payloads.iter().map(|payload| PyBytes::new(py, payload))).into()
+}
+
+impl YRoomMessage {
+    fn from_payloads(payloads: &[Vec<u8>], broadcast_payloads: &[Vec<u8>]) -> YRoomMessage {
+        Python::with_gil(|py| YRoomMessage {
+            payloads: make_payloads(py, payloads),
+            broadcast_payloads: make_payloads(py, broadcast_payloads),
+        })
+    }
+}
+
+impl Default for YRoomMessage {
+    fn default() -> Self {
+        YRoomMessage::from_payloads(&[], &[])
+    }
 }
 
 #[pymethods]
 impl YRoomMessage {
     pub fn __str__(&self) -> String {
         format!(
-            "YRoomMessage(payload: {}, broadcast_payload: {})",
-            self.payload, self.broadcast_payload
+            "YRoomMessage(payloads: {}, broadcast_payloads: {})",
+            self.payloads, self.broadcast_payloads
         )
     }
 
     pub fn __repr__(&self) -> String {
         self.__str__()
     }
 }
@@ -297,18 +356,15 @@
 
     pub fn handle_message(&mut self, room: String, conn_id: u64, payload: Vec<u8>) -> YRoomMessage {
         self.get_room(&room).handle_message(conn_id, payload)
     }
 
     pub fn disconnect(&mut self, room: String, conn_id: u64) -> YRoomMessage {
         let broadcast_payload = self.get_room(&room).disconnect(conn_id);
-        Python::with_gil(|py| YRoomMessage {
-            payload: PyBytes::new(py, &[]).into(),
-            broadcast_payload: PyBytes::new(py, &broadcast_payload).into(),
-        })
+        YRoomMessage::from_payloads(&[], &broadcast_payload)
     }
 
     pub fn has_room(&self, room: String) -> bool {
         self.rooms.contains_key(&room)
     }
 
     pub fn is_room_alive(&self, room: String) -> bool {
@@ -444,82 +500,95 @@
         YRoom {
             awareness,
             connections: Arc::new(Mutex::new(HashMap::new())),
             settings,
         }
     }
 
+    fn write_start_sync(&self, encoder: &mut EncoderWrapper) {
+        let sv = self.awareness.doc().transact().state_vector();
+        encoder.push(Message::Sync(SyncMessage::SyncStep1(sv)));
+        if !self.awareness.clients().is_empty() {
+            if let Ok(awareness_update) = self.awareness.update() {
+                encoder.push(Message::Awareness(awareness_update));
+            }
+        }
+    }
+
     fn connect(&mut self, conn_id: u64) -> YRoomMessage {
         let connections = self.connections.lock();
         connections
             .unwrap()
             .entry(conn_id)
             .or_insert_with(HashSet::new);
 
-        let mut encoder = EncoderWrapper::new(&self.settings.protocol_version, None);
+        let mut encoder = EncoderWrapper::new(
+            &self.settings.protocol_version,
+            self.settings.disable_pipelining,
+            None,
+        );
 
         if self.settings.server_start_sync {
-            let sv = self.awareness.doc().transact().state_vector();
-            encoder.push(Message::Sync(SyncMessage::SyncStep1(sv)));
-            if !self.awareness.clients().is_empty() {
-                if let Ok(awareness_update) = self.awareness.update() {
-                    encoder.push(Message::Awareness(awareness_update));
-                }
-            }
+            self.write_start_sync(&mut encoder);
         }
-        let payload = encoder.to_vec();
+        let payloads = encoder.to_vecs();
         Python::with_gil(|py| YRoomMessage {
-            payload: PyBytes::new(py, &payload).into(),
-            broadcast_payload: PyBytes::new(py, &[]).into(),
+            payloads: make_payloads(py, &payloads),
+            broadcast_payloads: make_payloads(py, &[]),
         })
     }
 
     pub fn handle_message(&mut self, conn_id: u64, payload: Vec<u8>) -> YRoomMessage {
-        log::debug!("message: {:?}", payload);
+        log::trace!("yroom handle_message: {:?}", payload);
         let cursor = Cursor::new(&payload);
         let decoder = match DecoderWrapper::new(
             &self.settings.protocol_version,
             cursor,
             self.settings.name_prefix,
         ) {
             Ok(decoder) => decoder,
             Err(e) => {
                 log::error!("Error decoding message: {}", e);
                 // TODO: return error message
-                return Python::with_gil(|py| YRoomMessage {
-                    payload: PyBytes::new(py, &[]).into(),
-                    broadcast_payload: PyBytes::new(py, &[]).into(),
-                });
+                return YRoomMessage::default();
             }
         };
 
         let mut sync_encoder = EncoderWrapper::new(
             &self.settings.protocol_version,
+            self.settings.disable_pipelining,
             decoder.document_name.clone(),
         );
         let mut update_encoder = EncoderWrapper::new(
             &self.settings.protocol_version,
+            self.settings.disable_pipelining,
             decoder.document_name.clone(),
         );
 
         decoder.for_each(|message_result| match message_result {
             Ok(message) => match message {
                 Message::Sync(SyncMessage::SyncStep1(sv)) => {
-                    let txn = self.awareness.doc_mut().transact_mut();
-                    let data = match self.settings.protocol_version {
-                        ProtocolVersion::V1 => txn.encode_diff_v1(&sv),
-                        ProtocolVersion::V2 => {
-                            let mut enc = EncoderV2::new();
-                            txn.encode_diff(&sv, &mut enc);
-                            enc.to_vec()
+                    let data = {
+                        let txn = self.awareness.doc_mut().transact_mut();
+                        match self.settings.protocol_version {
+                            ProtocolVersion::V1 => txn.encode_diff_v1(&sv),
+                            ProtocolVersion::V2 => {
+                                let mut enc = EncoderV2::new();
+                                txn.encode_diff(&sv, &mut enc);
+                                enc.to_vec()
+                            }
                         }
                     };
-                    log::debug!("message: {:?}", data);
+                    log::trace!("yroom sync message: {:?}", data);
                     let message = Message::Sync(SyncMessage::SyncStep2(data));
                     sync_encoder.push(message);
+                    // Send sync step 1 to client when server has not started sync yet
+                    if self.settings.server_start_sync {
+                        self.write_start_sync(&mut sync_encoder);
+                    }
                 }
                 Message::Sync(SyncMessage::SyncStep2(data)) => {
                     let update = match self.settings.protocol_version {
                         ProtocolVersion::V1 => Update::decode_v1(&data),
                         ProtocolVersion::V2 => Update::decode_v2(&data),
                     };
                     match update {
@@ -584,38 +653,44 @@
                     log::warn!("Unhandled custom message received. Type: {}", custom_type);
                 }
             },
             Err(err) => {
                 log::warn!("Bad message from connection {}: {:?}", conn_id, err);
             }
         });
-
-        Python::with_gil(|py| YRoomMessage {
-            payload: PyBytes::new(py, &sync_encoder.to_vec()).into(),
-            broadcast_payload: PyBytes::new(py, &update_encoder.to_vec()).into(),
-        })
+        YRoomMessage::from_payloads(&sync_encoder.to_vecs(), &update_encoder.to_vecs())
     }
 
-    pub fn disconnect(&mut self, conn_id: u64) -> Vec<u8> {
+    pub fn disconnect(&mut self, conn_id: u64) -> Vec<Vec<u8>> {
         {
             let mut connections = self.connections.lock().unwrap();
             let client_ids = connections.get(&conn_id);
             if let Some(client_ids) = client_ids {
                 client_ids.iter().for_each(|client_id| {
                     self.awareness.remove_state(*client_id);
                 });
             }
             connections.remove(&conn_id);
         }
-        // FIXME: Can't give possibly necessary name prefix on disconnect
-        let mut encoder = EncoderWrapper::new(&self.settings.protocol_version, None);
+        // Can't broadcast disconnect for name prefixed protocol
+        // as name prefix is not present on disconnect
+        // but that's OK as name prefixed protocol client usually
+        // sends final awareness update before disconnect
+        if self.settings.name_prefix {
+            return vec![];
+        }
+        let mut encoder = EncoderWrapper::new(
+            &self.settings.protocol_version,
+            self.settings.disable_pipelining,
+            None,
+        );
         if let Ok(awareness_update) = self.awareness.update() {
             encoder.push(Message::Awareness(awareness_update));
         }
-        encoder.to_vec()
+        encoder.to_vecs()
     }
 
     pub fn serialize(&self) -> Vec<u8> {
         let txn = self.awareness.doc().transact();
         match self.settings.protocol_version {
             ProtocolVersion::V1 => txn.encode_state_as_update_v1(&StateVector::default()),
             ProtocolVersion::V2 => txn.encode_state_as_update_v2(&StateVector::default()),
```

### Comparing `yroom-0.0.6/tests/test_yroom.py` & `yroom-0.0.7/tests/test_yroom.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,16 +5,16 @@
 from yroom import YRoomManager
 
 
 def test_connect():
     room_name = "test"
     manager = YRoomManager()
     message = manager.connect(room_name, 1)
-    assert len(message.payload) > 0
-    assert len(message.broadcast_payload) == 0
+    assert len(message.payloads) > 0
+    assert len(message.broadcast_payloads) == 0
     assert manager.has_room(room_name)
     assert manager.is_room_alive(room_name)
     assert manager.list_rooms() == [room_name]
     manager.remove_room(room_name)
     assert not manager.has_room(room_name)
     assert manager.list_rooms() == []
 
@@ -25,29 +25,30 @@
     with d1.begin_transaction() as txn:
         text.extend(txn, "hello world!")
     update_data = Y.encode_state_as_update(d1)
 
     room_name = "test"
     manager = YRoomManager()
     message = manager.connect_with_data(room_name, 1, update_data)
-    assert len(message.payload) > 0
-    assert len(message.broadcast_payload) == 0
+    assert len(message.payloads) > 0
+    assert len(message.payloads) > 0
+    assert len(message.broadcast_payloads) == 0
     assert manager.serialize_room(room_name) == update_data
 
 
 def test_disconnect():
     room_name = "test"
     conn_id = 1
     manager = YRoomManager()
     manager.connect(room_name, conn_id)
     assert manager.has_room(room_name)
     assert manager.is_room_alive(room_name)
     message = manager.disconnect(room_name, conn_id)
-    assert len(message.payload) == 0
-    assert len(message.broadcast_payload) > 0
+    assert len(message.payloads) == 0
+    assert len(message.broadcast_payloads) > 0
     assert not manager.is_room_alive(room_name)
     assert manager.list_rooms() == [room_name]
     manager.remove_room(room_name)
     assert not manager.has_room(room_name)
     assert manager.list_rooms() == []
 
 
@@ -111,44 +112,44 @@
     message = manager.connect(room_name, client_id)
     initial_payload = b"".join(
         [
             b"\x00\x00",  # sync step 1
             b"\x01" b"\x00",  # len message  # zero length state vector
         ]
     )
-    assert message.payload == initial_payload
+    assert message.payloads == [initial_payload]
     with d1.begin_transaction() as txn:
         diff = txn.diff_v1(None)
 
     payload = b"".join(
         [
             b"\x00\x01",  # sync step 2
             len(diff).to_bytes(1, "big"),  # len of diff
             diff,  # the diff
         ]
     )
     message = manager.handle_message(room_name, client_id, payload)
-    assert message.payload == b""
-    assert message.broadcast_payload == b""
+    assert message.payloads == []
+    assert message.broadcast_payloads == []
     assert manager.export_text(room_name, "test") == "hello world!"
 
 
 def test_server_no_sync_start():
     empty = Y.YDoc()
     d1 = Y.YDoc()
     text = d1.get_text("test")
     with d1.begin_transaction() as txn:
         text.extend(txn, "hello world!")
 
     room_name = "test"
     client_id = 1
     manager = YRoomManager({room_name: {"SERVER_START_SYNC": False}})
     message = manager.connect(room_name, client_id)
-    assert message.payload == b""
-    assert message.broadcast_payload == b""
+    assert message.payloads == []
+    assert message.broadcast_payloads == []
 
     state_vector = Y.encode_state_vector(d1)
     sv_len = len(state_vector).to_bytes(1, "big")
     client_sync_step1_payload = b"".join(
         [
             b"\x00\x00",  # sync step 1
             sv_len,
@@ -158,22 +159,24 @@
     message = manager.handle_message(room_name, client_id, client_sync_step1_payload)
 
     # Simulate empty document diff with d1
     with empty.begin_transaction() as txn:
         diff = txn.diff_v1(state_vector)
     len_diff = len(diff).to_bytes(1, "big")
 
-    assert message.payload == b"".join(
-        [
-            b"\x00\x01",  # sync step 2
-            len_diff,  # len of buffer
-            diff,  # diffed update
-        ]
-    )
-    assert message.broadcast_payload == b""
+    assert message.payloads == [
+        b"".join(
+            [
+                b"\x00\x01",  # sync step 2
+                len_diff,  # len of buffer
+                diff,  # diffed update
+            ]
+        )
+    ]
+    assert message.broadcast_payloads == []
 
 
 def test_client_prefix():
     """TipTap HocusPocus Collaboration uses a prefix in protocol messages"""
     d1 = Y.YDoc()
     name = "test"
     prefix = b"".join([len(name).to_bytes(1, "big"), name.encode("utf-8")])
@@ -188,32 +191,34 @@
             room_name: {
                 "SERVER_START_SYNC": False,
                 "PROTOCOL_NAME_PREFIX": True,
             }
         }
     )
     message = manager.connect(room_name, client_id)
-    assert message.payload == b""
-    assert message.broadcast_payload == b""
+    assert message.payloads == []
+    assert message.broadcast_payloads == []
 
     state_vector = Y.encode_state_vector(d1)
     sv_len = len(state_vector).to_bytes(1, "big")
     client_sync_step1_payload = b"".join(
         [
             prefix,
             b"\x00\x00",  # sync step 1
             sv_len,
             state_vector,
         ]
     )
 
     message = manager.handle_message(room_name, client_id, client_sync_step1_payload)
-    assert message.payload == b"".join(
-        [
-            prefix,
-            b"\x00\x01",  # sync step 2
-            b"\x02",  # len of buffer
-            b"\x00\x00",  # diffed update
-        ]
-    )
+    assert message.payloads == [
+        b"".join(
+            [
+                prefix,
+                b"\x00\x01",  # sync step 2
+                b"\x02",  # len of buffer
+                b"\x00\x00",  # diffed update
+            ]
+        )
+    ]
 
-    assert message.broadcast_payload == b""
+    assert message.broadcast_payloads == []
```

### Comparing `yroom-0.0.6/yroom.pyi` & `yroom-0.0.7/yroom.pyi`

 * *Files 1% similar despite different names*

```diff
@@ -4,16 +4,16 @@
     """
     Container that holds two members: `payload` and `broadcast_payload`.
     `payload` is a message that should be sent to the connection that sent the message.
     `broadcast_payload` is a message that should be sent to all connections in the room.
     Either or both of the members can be of zero length and then must not be sent.
     """
 
-    payload: bytes
-    broadcast_payload: bytes
+    payloads: List[bytes]
+    broadcast_payloads: List[bytes]
 
 class YRoomSettings(TypedDict):
     wire_version: int  # The Yjs encoding/decoding version to use (1 or 2, default: 1)
     name_prefixed: bool  # Whether to expect a prefix for wire messages (default: False)
     server_start_sync: bool  # Whether to start sync on connect (default: True)
 
 class YRoomManager:
```

### Comparing `yroom-0.0.6/Cargo.lock` & `yroom-0.0.7/Cargo.lock`

 * *Files 0% similar despite different names*

```diff
@@ -499,15 +499,15 @@
  "lib0",
  "thiserror",
  "yrs",
 ]
 
 [[package]]
 name = "yroom"
-version = "0.0.6"
+version = "0.0.7"
 dependencies = [
  "lib0",
  "log",
  "pyo3",
  "pyo3-log",
  "y-sync",
  "yrs",
```

### Comparing `yroom-0.0.6/PKG-INFO` & `yroom-0.0.7/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: yroom
-Version: 0.0.6
+Version: 0.0.7
 Classifier: Programming Language :: Rust
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 Requires-Dist: pytest; extra == 'test'
 Requires-Dist: ypy; extra == 'test'
 Provides-Extra: test
 License-File: LICENSE
```

