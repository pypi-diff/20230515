# Comparing `tmp/h3sed-1.0-py2.py3-none-any.whl.zip` & `tmp/h3sed-1.6-py2-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,35 @@
-Zip file size: 93453 bytes, number of entries: 33
--rw-rw-rw-  2.0 fat       76 b- defN 22-Jan-19 20:09 h3sed/__init__.py
--rw-rw-rw-  2.0 fat       94 b- defN 22-Jan-19 20:09 h3sed/__main__.py
--rw-rw-rw-  2.0 fat     7015 b- defN 22-Jan-19 20:09 h3sed/conf.py
--rw-rw-rw-  2.0 fat    61164 b- defN 22-Jan-19 20:09 h3sed/gui.py
--rw-rw-rw-  2.0 fat    10896 b- defN 22-Jan-19 20:09 h3sed/guibase.py
--rw-rw-rw-  2.0 fat    15365 b- defN 22-Jan-19 20:09 h3sed/images.py
--rw-rw-rw-  2.0 fat     5346 b- defN 22-Jan-19 20:09 h3sed/main.py
--rw-rw-rw-  2.0 fat    41442 b- defN 22-Jan-19 20:09 h3sed/metadata.py
--rw-rw-rw-  2.0 fat     2796 b- defN 22-Jan-19 20:09 h3sed/templates.py
--rw-rw-rw-  2.0 fat      263 b- defN 22-Jan-19 20:09 h3sed/etc/h3sed.ini
--rw-rw-rw-  2.0 fat        0 b- defN 22-Jan-19 20:09 h3sed/lib/__init__.py
--rw-rw-rw-  2.0 fat     9543 b- defN 22-Jan-19 20:09 h3sed/lib/controls.py
--rw-rw-rw-  2.0 fat    11589 b- defN 22-Jan-19 20:09 h3sed/lib/util.py
--rw-rw-rw-  2.0 fat    17561 b- defN 22-Jan-19 20:09 h3sed/lib/wx_accel.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Jan-19 20:09 h3sed/lib/vendor/__init__.py
--rw-rw-rw-  2.0 fat     7396 b- defN 22-Jan-19 20:09 h3sed/lib/vendor/step.py
--rw-rw-rw-  2.0 fat     5846 b- defN 22-Jan-19 20:09 h3sed/plugins/__init__.py
--rw-rw-rw-  2.0 fat    25434 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/__init__.py
--rw-rw-rw-  2.0 fat     8806 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/army.py
--rw-rw-rw-  2.0 fat    13370 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/artifacts.py
--rw-rw-rw-  2.0 fat     5877 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/inventory.py
--rw-rw-rw-  2.0 fat     6577 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/skills.py
--rw-rw-rw-  2.0 fat     4816 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/spells.py
--rw-rw-rw-  2.0 fat     7719 b- defN 22-Jan-19 20:09 h3sed/plugins/hero/stats.py
--rw-rw-rw-  2.0 fat     2110 b- defN 22-Jan-19 20:09 h3sed/plugins/version/__init__.py
--rw-rw-rw-  2.0 fat    14474 b- defN 22-Jan-19 20:09 h3sed/plugins/version/hota.py
--rw-rw-rw-  2.0 fat     6282 b- defN 22-Jan-19 20:09 h3sed/plugins/version/sod.py
--rw-rw-rw-  2.0 fat     1100 b- defN 22-Jan-19 20:11 h3sed-1.0.dist-info/LICENSE.md
--rw-rw-rw-  2.0 fat     4220 b- defN 22-Jan-19 20:11 h3sed-1.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      116 b- defN 22-Jan-19 20:11 h3sed-1.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       38 b- defN 22-Jan-19 20:11 h3sed-1.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        6 b- defN 22-Jan-19 20:11 h3sed-1.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2602 b- defN 22-Jan-19 20:11 h3sed-1.0.dist-info/RECORD
-33 files, 299939 bytes uncompressed, 89357 bytes compressed:  70.2%
+Zip file size: 131303 bytes, number of entries: 33
+-rw-rw-rw-  2.0 fat       76 b- defN 22-Jan-20 18:23 h3sed/__init__.py
+-rw-rw-rw-  2.0 fat       94 b- defN 22-Jan-20 18:23 h3sed/__main__.py
+-rw-rw-rw-  2.0 fat     7364 b- defN 23-May-15 18:11 h3sed/conf.py
+-rw-rw-rw-  2.0 fat    67997 b- defN 23-May-15 18:11 h3sed/gui.py
+-rw-rw-rw-  2.0 fat    10896 b- defN 22-Jan-20 18:23 h3sed/guibase.py
+-rw-rw-rw-  2.0 fat    41483 b- defN 23-Feb-26 17:55 h3sed/images.py
+-rw-rw-rw-  2.0 fat     5800 b- defN 23-Feb-25 09:56 h3sed/main.py
+-rw-rw-rw-  2.0 fat    41558 b- defN 23-Feb-25 10:52 h3sed/metadata.py
+-rw-rw-rw-  2.0 fat    25247 b- defN 23-Feb-26 18:38 h3sed/templates.py
+-rw-rw-rw-  2.0 fat      276 b- defN 23-Feb-26 11:37 h3sed/etc/h3sed.ini
+-rw-rw-rw-  2.0 fat        0 b- defN 22-Jan-20 18:23 h3sed/lib/__init__.py
+-rw-rw-rw-  2.0 fat    23257 b- defN 23-May-15 18:11 h3sed/lib/controls.py
+-rw-rw-rw-  2.0 fat    13977 b- defN 23-Feb-26 17:55 h3sed/lib/util.py
+-rw-rw-rw-  2.0 fat    17561 b- defN 22-Jan-20 18:23 h3sed/lib/wx_accel.py
+-rw-rw-rw-  2.0 fat        0 b- defN 22-Jan-20 18:23 h3sed/lib/vendor/__init__.py
+-rw-rw-rw-  2.0 fat     7446 b- defN 23-Feb-25 10:52 h3sed/lib/vendor/step.py
+-rw-rw-rw-  2.0 fat     6064 b- defN 23-Feb-26 17:55 h3sed/plugins/__init__.py
+-rw-rw-rw-  2.0 fat    51648 b- defN 23-May-15 18:11 h3sed/plugins/hero/__init__.py
+-rw-rw-rw-  2.0 fat     9604 b- defN 23-Feb-26 17:55 h3sed/plugins/hero/army.py
+-rw-rw-rw-  2.0 fat    14628 b- defN 23-Feb-26 17:55 h3sed/plugins/hero/artifacts.py
+-rw-rw-rw-  2.0 fat     6135 b- defN 23-Feb-26 17:55 h3sed/plugins/hero/inventory.py
+-rw-rw-rw-  2.0 fat     7174 b- defN 23-May-15 18:11 h3sed/plugins/hero/skills.py
+-rw-rw-rw-  2.0 fat     5001 b- defN 23-Feb-26 17:55 h3sed/plugins/hero/spells.py
+-rw-rw-rw-  2.0 fat     8128 b- defN 23-Feb-26 17:55 h3sed/plugins/hero/stats.py
+-rw-rw-rw-  2.0 fat     2110 b- defN 22-Jan-20 18:23 h3sed/plugins/version/__init__.py
+-rw-rw-rw-  2.0 fat    14496 b- defN 23-Feb-25 10:52 h3sed/plugins/version/hota.py
+-rw-rw-rw-  2.0 fat     6282 b- defN 22-Jan-20 18:23 h3sed/plugins/version/sod.py
+-rw-rw-rw-  2.0 fat     1100 b- defN 23-May-15 18:19 h3sed-1.6.dist-info/LICENSE.md
+-rw-rw-rw-  2.0 fat     4559 b- defN 23-May-15 18:19 h3sed-1.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       97 b- defN 23-May-15 18:19 h3sed-1.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       38 b- defN 23-May-15 18:19 h3sed-1.6.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        6 b- defN 23-May-15 18:19 h3sed-1.6.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2603 b- defN 23-May-15 18:19 h3sed-1.6.dist-info/RECORD
+33 files, 402705 bytes uncompressed, 127207 bytes compressed:  68.4%
```

## zipnote {}

```diff
@@ -75,26 +75,26 @@
 
 Filename: h3sed/plugins/version/hota.py
 Comment: 
 
 Filename: h3sed/plugins/version/sod.py
 Comment: 
 
-Filename: h3sed-1.0.dist-info/LICENSE.md
+Filename: h3sed-1.6.dist-info/LICENSE.md
 Comment: 
 
-Filename: h3sed-1.0.dist-info/METADATA
+Filename: h3sed-1.6.dist-info/METADATA
 Comment: 
 
-Filename: h3sed-1.0.dist-info/WHEEL
+Filename: h3sed-1.6.dist-info/WHEEL
 Comment: 
 
-Filename: h3sed-1.0.dist-info/entry_points.txt
+Filename: h3sed-1.6.dist-info/entry_points.txt
 Comment: 
 
-Filename: h3sed-1.0.dist-info/top_level.txt
+Filename: h3sed-1.6.dist-info/top_level.txt
 Comment: 
 
-Filename: h3sed-1.0.dist-info/RECORD
+Filename: h3sed-1.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## h3sed/conf.py

```diff
@@ -5,15 +5,15 @@
 and all values are kept in JSON.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     14.03.2020
-@modified    19.01.2022
+@modified    28.02.2023
 ------------------------------------------------------------------------------
 """
 try: from ConfigParser import RawConfigParser                 # Py2
 except ImportError: from configparser import RawConfigParser  # Py3
 import datetime
 import io
 import json
@@ -21,16 +21,16 @@
 import re
 import sys
 
 
 """Program title, version number and version date."""
 Name = "h3sed"
 Title = "Heroes3 Savegame Editor"
-Version = "1.0"
-VersionDate = "19.01.2022"
+Version = "1.6"
+VersionDate = "28.02.2023"
 
 if getattr(sys, "frozen", False):
     # Running as a pyinstaller executable
     ApplicationDirectory = os.path.dirname(sys.executable)
     PluginDirectory = os.path.join(getattr(sys, "_MEIPASS", ""), "h3sed", "plugins")
     EtcDirectory = ApplicationDirectory
 else:
@@ -40,19 +40,19 @@
 
 """Name of file where FileDirectives are kept."""
 ConfigFile = "%s.ini" % os.path.join(EtcDirectory, Name.lower())
 
 """List of attribute names that can be saved to and loaded from ConfigFile."""
 FileDirectives = [
     "Backup", "ConfirmUnsaved", "ConsoleHistoryCommands", "GameVersion",
-    "Populate", "RecentFiles", "SelectedPath", "WindowPosition", "WindowSize",
+    "RecentFiles", "RecentHeroes", "SelectedPath", "WindowPosition", "WindowSize",
 ]
 """List of user-modifiable attributes, saved if changed from default."""
 OptionalFileDirectives = [
-    "FileExtensions", "MaxConsoleHistory", "MaxRecentFiles",
+    "FileExtensions", "HeroToggles", "MaxConsoleHistory", "MaxRecentFiles",
     "PopupUnexpectedErrors", "StatusFlashLength",
 ]
 Defaults = {}
 
 """---------------------------- FileDirectives: ----------------------------"""
 
 """Current selected path in directory list."""
@@ -60,37 +60,40 @@
 
 """Create a backup of savegame file before saving edits."""
 Backup = True
 
 """Confirm on closing files with unsaved changes."""
 ConfirmUnsaved = True
 
-"""Load savefile content to UI upon opening."""
-Populate = True
-
 """Savefile filename extensions, as {'description': ('.ext1', '.ext2')}."""
 FileExtensions = [("Heroes3 savefiles",               (".cgm", ".gm1", ".gm2", ".gm3", ".gm4", ".gm5", ".gm6", ".gm7", ".gm8")),
                   ("Heroes3 single player savefiles", (".gm1", )),
                   ("Heroes3 multi-player savefiles",  (".gm2", ".gm3", ".gm4", ".gm5", ".gm6", ".gm7", ".gm8")),
                   ("Heroes3 campaign savefiles",      (".cgm", ))]
 
 """History of commands entered in console."""
 ConsoleHistoryCommands = []
 
 """Default game version for savefiles."""
 GameVersion = ""
 
+"""Hero index categories toggle state, as {name: false}."""
+HeroToggles = {}
+
 """Contents of Recent Files menu."""
 RecentFiles = []
 
+"""Contents of Recent Heroes menu, as [[hero name, file path]]."""
+RecentHeroes = []
+
 """Main window position, (x, y)."""
 WindowPosition = None
 
 """Main window size in pixels, [w, h] or [-1, -1] for maximized."""
-WindowSize = (600, 700)
+WindowSize = (650, 700)
 
 """---------------------------- /FileDirectives ----------------------------"""
 
 """Whether logging to log window is enabled."""
 LogEnabled = True
 
 """Whether to pop up message dialogs for unhandled errors."""
@@ -108,15 +111,15 @@
 """Console window size in pixels, (width, height)."""
 ConsoleSize = (600, 300)
 
 """Maximum number of console history commands to store."""
 MaxConsoleHistory = 1000
 
 """Maximum length of a tab title, overflow will be cut on the left."""
-MaxTabTitleLength = 60
+MaxTabTitleLength = 30
 
 """Name of font used in HTML content."""
 HtmlFontName = "Tahoma"
 
 """Window background colour."""
 BgColour = "#FFFFFF"
 
@@ -128,20 +131,29 @@
 
 """Widget (button etc) background colour."""
 WidgetColour = "#D4D0C8"
 
 """Colour for clickable links."""
 LinkColour = "#0000FF"
 
+"""Colour for original value in savegame diff."""
+DiffOldColour = "#FFAAAA"
+
+"""Colour for new value in savegame diff."""
+DiffNewColour = "#AAFFAA"
+
 """Duration of "flashed" status message on StatusBar, in seconds."""
 StatusFlashLength = 20
 
 """How many items in the Recent Files menu."""
 MaxRecentFiles = 20
 
+"""How many items in the Recent Heroes menu."""
+MaxRecentHeroes = 20
+
 
 def load():
     """Loads FileDirectives from ConfigFile into this module's attributes."""
     global Defaults
 
     try: VARTYPES = (basestring, bool, int, long, list, tuple, dict, type(None))         # Py2
     except Exception: VARTYPES = (bytes, str, bool, int, list, tuple, dict, type(None))  # Py3
```

## h3sed/gui.py

```diff
@@ -3,24 +3,25 @@
 h3sed UI application main window class and savepage class.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     14.03.2020
-@modified    19.01.2022
+@modified    26.02.2023
 ------------------------------------------------------------------------------
 """
 import datetime
 import functools
 import logging
 import os
 import shutil
 import sys
 import tempfile
+import time
 
 import wx
 import wx.adv
 import wx.html
 import wx.lib.agw.flatnotebook
 import wx.lib.agw.labelbook
 import wx.lib.newevent
@@ -70,16 +71,15 @@
         self.pages_visited = []
 
         icons = images.get_appicons()
         self.SetIcons(icons)
         self.frame_console.SetIcons(icons)
 
         panel = self.panel_main = wx.Panel(self)
-        notebook = self.notebook = wx.lib.agw.flatnotebook.FlatNotebook(
-            panel, style=wx.NB_TOP,
+        notebook = self.notebook = wx.lib.agw.flatnotebook.FlatNotebook(panel,
             agwStyle=wx.lib.agw.flatnotebook.FNB_DROPDOWN_TABS_LIST |
                      wx.lib.agw.flatnotebook.FNB_MOUSE_MIDDLE_CLOSES_TABS |
                      wx.lib.agw.flatnotebook.FNB_NO_NAV_BUTTONS |
                      wx.lib.agw.flatnotebook.FNB_NO_TAB_FOCUS |
                      wx.lib.agw.flatnotebook.FNB_NO_X_BUTTON |
                      wx.lib.agw.flatnotebook.FNB_FF2)
         ColourManager.Manage(notebook, "ActiveTabColour",        wx.SYS_COLOUR_WINDOW)
@@ -126,21 +126,21 @@
         # Register Ctrl-F4 close and Ctrl-1..9 tab handlers
         def on_close_hotkey(event=None):
             notebook and notebook.DeletePage(notebook.GetSelection())
         def on_tab_hotkey(number, event=None):
             if notebook and notebook.GetSelection() != number \
             and number < notebook.GetPageCount():
                 notebook.SetSelection(number)
-                self.on_change_page(None)
+                self.on_change_page()
 
         id_close = wx.NewIdRef().Id
-        accelerators = [(wx.ACCEL_CTRL, k, id_close) for k in [wx.WXK_F4, ord("W")]]
+        accelerators = [(wx.ACCEL_CMD, k, id_close) for k in [wx.WXK_F4, ord("W")]]
         for i in range(9):
             id_tab = wx.NewIdRef().Id
-            accelerators += [(wx.ACCEL_CTRL, ord(str(i + 1)), id_tab)]
+            accelerators += [(wx.ACCEL_CMD, ord(str(i + 1)), id_tab)]
             notebook.Bind(wx.EVT_MENU, functools.partial(on_tab_hotkey, i), id=id_tab)
 
         notebook.Bind(wx.EVT_MENU, on_close_hotkey, id=id_close)
         notebook.SetAcceleratorTable(wx.AcceleratorTable(accelerators))
 
 
         class FileDrop(wx.FileDropTarget):
@@ -189,15 +189,15 @@
         ColourManager.Manage(page, "BackgroundColour", "MainBgColour")
         notebook.AddPage(page, "Choose file")
         sizer = page.Sizer = wx.BoxSizer(wx.VERTICAL)
         hsizer = wx.BoxSizer(wx.HORIZONTAL)
 
         text_file = self.text_file = wx.TextCtrl(page)
         button_open   = self.button_open   = wx.Button(page, label="&Open")
-        button_browse = self.button_browse = wx.Button(page, label="&Browse")
+        button_browse = self.button_browse = wx.Button(page, label="&Browse..")
         dir_ctrl = self.dir_ctrl = wx.GenericDirCtrl(page,
             style=wx.DIRCTRL_SHOW_FILTERS, filter=metadata.wildcard(), defaultFilter=0)
         dialog = self.dialog_browse = wx.FileDialog(
             parent=self, message="Select file", wildcard=metadata.wildcard(),
             style=wx.FD_FILE_MUST_EXIST | wx.FD_OPEN | wx.RESIZE_BORDER
         )
 
@@ -246,52 +246,61 @@
         menu_close = self.menu_close = menu_file.Append(
             wx.ID_ANY, "&Close file\tCtrl-F4", "Close current savefile"
         )
         menu_reload = self.menu_reload = menu_file.Append(
             wx.ID_ANY, "Re&load", "Reload savefile, losing any current changes"
         )
         menu_save = self.menu_save = menu_file.Append(
-            wx.ID_ANY, "&Save", "Save changes to the active file"
+            wx.ID_ANY, "&Save", "Save the active file"
         )
         menu_save_as = self.menu_save_as = menu_file.Append(
             wx.ID_ANY, "Save &as...", "Save the active file under a new name"
         )
         menu_recent = wx.Menu()
         menu_file.AppendSubMenu(menu_recent, "&Recent files", "Recently opened files")
         menu_file.AppendSeparator()
+        menu_recent_hero = wx.Menu()
+        menu_file.AppendSubMenu(menu_recent_hero, "Recent &heroes", "Recently opened heroes")
+        menu_file.AppendSeparator()
         menu_options = wx.Menu()
         menu_file.AppendSubMenu(menu_options, "Opt&ions")
-        menu_populate = self.menu_populate = menu_options.Append(
-            wx.ID_ANY, "&Auto-load savefile content", "Populate content to UI on opening savefile",
-            kind=wx.ITEM_CHECK
-        )
-        menu_populate.Check(conf.Populate)
         menu_backup = self.menu_backup = menu_options.Append(
-            wx.ID_ANY, "&Back up each save", "Create backup copy of savefile before saving changes",
+            wx.ID_ANY, "&Back up files before saving", "Create backup copy of savefile before saving changes",
             kind=wx.ITEM_CHECK
         )
         menu_backup.Check(conf.Backup)
         menu_confirm = self.menu_confirm = menu_options.Append(
             wx.ID_ANY, "&Confirm unsaved changes", "Ask for confirmation on closing files with unsaved changes",
             kind=wx.ITEM_CHECK
         )
+        menu_options.AppendSeparator()
+        menu_clear = self.menu_clear = menu_options.Append(
+            wx.ID_ANY, "Clear &recent items", "Clear recent files and heroes list",
+        )
         menu_confirm.Check(conf.ConfirmUnsaved)
         menu_file.AppendSeparator()
         menu_exit = self.menu_exit = \
             menu_file.Append(wx.ID_ANY, "E&xit\tAlt-X", "Exit")
 
 
         menu_edit = self.menu_edit = wx.Menu()
         menu.Append(menu_edit, "&Edit")
         menu_undo = self.menu_undo = menu_edit.Append(
             wx.ID_UNDO, "&Undo", "Undo the last action"
         )
         menu_redo = self.menu_redo = menu_edit.Append(
             wx.ID_REDO, "&Redo", "Redo the previously undone action"
         )
+        menu_history = self.menu_history = menu_edit.Append(
+            wx.ID_ANY, "Command &history", "View current changes done to savegame"
+        )
+        menu_edit.AppendSeparator()
+        menu_changes = self.menu_changes = menu_edit.Append(
+            wx.ID_ANY, "Show unsaved &changes", "Show pending changes to savegame"
+        )
 
         menu_help = wx.Menu()
         menu.Append(menu_help, "&Help")
 
         menu_log = self.menu_log = menu_help.Append(wx.ID_ANY,
             "Show &log window", "Show/hide the log messages window",
             kind=wx.ITEM_CHECK)
@@ -301,50 +310,58 @@
         menu_help.AppendSeparator()
         menu_about = self.menu_about = menu_help.Append(
             wx.ID_ANY, "&About %s" % conf.Title,
             "Show program information and copyright")
 
         menu_close.Enabled = menu_reload.Enabled = False
         menu_save.Enabled = menu_save_as.Enabled = False
+        for x in menu_edit.MenuItems: x.Enable(False)
 
         self.history_file = wx.FileHistory(conf.MaxRecentFiles)
         self.history_file.UseMenu(menu_recent)
-        # Reverse list, as FileHistory works like a stack
-        [self.history_file.AddFileToHistory(f) for f in conf.RecentFiles[::-1]]
-        self.Bind(wx.EVT_MENU_RANGE, self.on_recent_file, id=wx.ID_FILE1,
-                  id2=wx.ID_FILE1 + conf.MaxRecentFiles)
+        for f in conf.RecentFiles[::-1]: self.history_file.AddFileToHistory(f)
+        self.Bind(wx.EVT_MENU_RANGE, self.on_recent_file, id=self.history_file.BaseId,
+                  id2=self.history_file.BaseId + conf.MaxRecentFiles)
+        self.history_hero = controls.ItemHistory(conf.MaxRecentHeroes)
+        self.history_hero.UseMenu(menu_recent_hero)
+        self.history_hero.Formatter = "\t".join
+        for x in conf.RecentHeroes[::-1]: self.history_hero.AddItem(x)
+        self.Bind(wx.EVT_MENU_RANGE, self.on_recent_hero, id=self.history_hero.BaseId,
+                  id2=self.history_hero.BaseId + conf.MaxRecentHeroes)
 
         self.Bind(wx.EVT_MENU, self.on_open_savefile,    menu_open)
         self.Bind(wx.EVT_MENU, self.on_close_savefile,   menu_close)
         self.Bind(wx.EVT_MENU, self.on_reload_savefile,  menu_reload)
         self.Bind(wx.EVT_MENU, self.on_save_savefile,    menu_save)
         self.Bind(wx.EVT_MENU, self.on_save_savefile_as, menu_save_as)
-        self.Bind(wx.EVT_MENU, self.on_menu_populate,    menu_populate)
         self.Bind(wx.EVT_MENU, self.on_menu_backup,      menu_backup)
         self.Bind(wx.EVT_MENU, self.on_menu_confirm,     menu_confirm)
+        self.Bind(wx.EVT_MENU, self.on_clear_recent,     menu_clear)
         self.Bind(wx.EVT_MENU, self.on_exit,             menu_exit)
         self.Bind(wx.EVT_MENU, self.on_undo_savefile,    menu_undo)
         self.Bind(wx.EVT_MENU, self.on_redo_savefile,    menu_redo)
         self.Bind(wx.EVT_MENU, self.on_showhide_log,     menu_log)
         self.Bind(wx.EVT_MENU, self.on_toggle_console,   menu_console)
         self.Bind(wx.EVT_MENU, self.on_about,            menu_about)
+        self.Bind(wx.EVT_MENU, self.on_show_changes,     menu_changes)
+        self.Bind(wx.EVT_MENU, self.on_open_history,     menu_history)
 
 
     def create_toolbar(self):
         """Creates the program toolbar."""
         TOOLS = [("Open",    wx.ID_OPEN,    wx.ART_FILE_OPEN,    self.on_open_savefile),
                  ("Save",    wx.ID_SAVE,    wx.ART_FILE_SAVE,    self.on_save_savefile),
                  ("Save as", wx.ID_SAVEAS,  wx.ART_FILE_SAVE_AS, self.on_save_savefile_as),
                  (),
                  ("Undo",    wx.ID_UNDO,    wx.ART_UNDO,         self.on_undo_savefile),
                  ("Redo",    wx.ID_REDO,    wx.ART_REDO,         self.on_redo_savefile),
                  (),
                  ("Reload",  wx.ID_REFRESH, "ToolbarRefresh",    self.on_reload_savefile)]
         TOOL_HELPS = {wx.ID_OPEN:    "Choose a savefile to open",
-                      wx.ID_SAVE:    "Save changes to the active file",
+                      wx.ID_SAVE:    "Save the active file",
                       wx.ID_SAVEAS:  "Save the active file under a new name",
                       wx.ID_UNDO:    "Undo the last action",
                       wx.ID_REDO:    "Redo the previously undone action",
                       wx.ID_REFRESH: "Reload savefile, losing any current changes"}
         tb = self.CreateToolBar(wx.TB_FLAT | wx.TB_HORIZONTAL | wx.TB_TEXT)
         tb.SetToolBitmapSize((16, 16))
         for tool in TOOLS:
@@ -378,15 +395,15 @@
             self.memoryfs["handler"].RemoveFile(abouticon)
         self.memoryfs["handler"].AddFile(abouticon, img.Image, wx.BITMAP_TYPE_PNG)
         self.memoryfs["files"][abouticon] = 1
 
 
     def load_savefile(self, filename, silent=False):
         """
-        Tries to load the specified savefile, and returns unzipped contents.
+        Tries to load the specified savefile, returns Savefile instance.
 
         @param   silent  if true, no error popups on failing to open the file
         """
         savefile = None
         if os.path.exists(filename):
             try:
                 savefile = metadata.Savefile(filename)
@@ -417,46 +434,53 @@
         Tries to load the specified file, if not already open, create a
         subpage for it, if not already created, and focuses the subpage.
 
         @return  savefile page instance
         """
         opts = self.files.get(filename) or {}
         page = opts.get("page")
-        if not page:
-            savefile = self.load_savefile(filename)
-            if not savefile: return
-
-            guibase.status("Opening page for %s." % filename, flash=True)
-            tab_title = self.get_unique_tab_title(filename)
-            opts.update(filename=filename, savefile=savefile, title=tab_title)
-            page = opts["page"] = SavefilePage(self.notebook, tab_title, savefile)
-            self.files[filename] = opts
-            conf.FilesOpen.add(filename)
-            conf.SelectedPath = filename
-            self.dir_ctrl.ExpandPath(conf.SelectedPath)
-            conf.save()
-        for i in range(self.notebook.GetPageCount()) if page else ():
+        if page:
+            for i in range(self.notebook.GetPageCount()):
+                if self.notebook.GetPage(i) == page:
+                    self.notebook.SetSelection(i)
+                    break # for i
+            self.on_change_page()
+            return
+
+        savefile = self.load_savefile(filename)
+        if not savefile: return
+
+        guibase.status("Opening page for %s." % filename, flash=True)
+        tab_title = self.get_unique_tab_title(filename)
+        opts.update(filename=filename, savefile=savefile, title=tab_title)
+        page = opts["page"] = SavefilePage(self.notebook, tab_title, savefile)
+        self.files[filename] = opts
+        conf.FilesOpen.add(filename)
+        conf.SelectedPath = filename
+        self.dir_ctrl.ExpandPath(conf.SelectedPath)
+        conf.save()
+        for i in range(self.notebook.GetPageCount()):
             if self.notebook.GetPage(i) == page:
                 self.notebook.SetSelection(i)
                 wx.CallAfter(self.update_notebook_header)
                 break # for i
         self.SendSizeEvent() # DirCtrl choice may need resizing
         return page
 
 
     def load_savefile_pages(self, filenames):
         """
         Tries to load the specified savefiles, if not already open, create
         subpages for them, if not already created, and focus the subpages.
         Skips files that are not gzipped.
         """
-        save_filenames, notsave_filenames = [], []
+        save_filenames, notsave_filenames, files0 = [], [], set(self.files)
         for f in filenames:
-            raw = self.load_savefile(f, silent=True)
-            if raw: save_filenames.append(f)
+            if f in self.files or self.load_savefile(f, silent=True):
+                save_filenames.append(f)
             else:
                 notsave_filenames.append(f)
                 guibase.status("%s is not a valid gzipped file.", f,
                                log=True, flash=True)
 
         if len(save_filenames) == 1:
             self.load_savefile_page(save_filenames[0])
@@ -554,33 +578,36 @@
             self.ToolBar.EnableTool(wx.ID_REDO,    page.undoredo.CanRedo())
             self.ToolBar.EnableTool(wx.ID_SAVEAS,  True)
             self.ToolBar.EnableTool(wx.ID_REFRESH, True)
             self.ToolBar.EnableTool(self.combo_game.Id, self.combo_game.Count > 1)
         self.combo_game.Enable(isinstance(page, SavefilePage) and self.combo_game.Count > 1)
 
 
-    def on_change_page(self, event):
+    def on_change_page(self, event=None):
         """
         Handler for changing a page in the main Notebook, remembers the visit.
         """
         if getattr(self, "_ignore_paging", False): return
         if event: event.Skip() # Pass event along to next handler
         page = self.notebook.GetCurrentPage()
         if not self.pages_visited or self.pages_visited[-1] != page:
             self.pages_visited.append(page)
 
         self.menu_close.Enabled = self.menu_reload.Enabled = False
         self.menu_save.Enabled = self.menu_save_as.Enabled = False
         self.menu_undo.Enabled = self.menu_redo.Enabled = False
+        self.menu_changes.Enabled = self.menu_history.Enabled = False
         self.Title, subtitle = conf.Title, ""
 
         if isinstance(page, SavefilePage):
             self.page_file_latest = page
             self.menu_save_as.Enabled = self.menu_close.Enabled = True
             self.menu_reload.Enabled = self.menu_save.Enabled = True
+            self.menu_changes.Enabled = page.get_unsaved()
+            self.menu_history.Enabled = bool(page.undoredo.Commands)
             page.undoredo.SetEditMenu(self.menu_edit)
             page.undoredo.SetMenuStrings()
         self.update_toolbar(page)
         self.update_fileinfo()
         self.update_title(page)
         wx.CallAfter(self.update_notebook_header)
 
@@ -633,36 +660,41 @@
     def on_showhide_log(self, event=None):
         """Handler for clicking to show/hide the log window."""
         if self.notebook.GetPageIndex(self.page_log) < 0:
             self.notebook.AddPage(self.page_log, "Log")
             self.page_log.is_hidden = False
             self.page_log.Show()
             self.notebook.SetSelection(self.notebook.GetPageCount() - 1)
-            self.on_change_page(None)
+            self.on_change_page()
             self.menu_log.Check(True)
         elif self.notebook.GetPageIndex(self.page_log) != self.notebook.GetSelection():
             self.notebook.SetSelection(self.notebook.GetPageCount() - 1)
-            self.on_change_page(None)
+            self.on_change_page()
             self.menu_log.Check(True)
         else:
             self.page_log.is_hidden = True
             self.notebook.RemovePage(self.notebook.GetPageIndex(self.page_log))
             self.menu_log.Check(False)
 
 
     def on_change_game_version(self, event):
         """Handler for selecting savegame version, updates plugin content and choices."""
         page = self.notebook.GetCurrentPage()
         p2 = next(x for x in plugins.version.PLUGINS
                   if x["label"] == event.EventObject.Value)
-
-        if page.savefile.version == p2["name"]: return
         p1 = next(x for x in plugins.version.PLUGINS
                   if x["name"] == page.savefile.version)
 
+        if page.savefile.version == p2["name"]: return
+        if page.get_unsaved():
+            event.EventObject.Value = p1["label"]
+            wx.MessageBox("Cannot change game version: there are unsaved changes.",
+                          conf.Title, wx.OK | wx.ICON_WARNING)
+            return
+
         def switch(opts):
             self.combo_game.Value = opts["label"]
             page.savefile.version = conf.GameVersion = opts["name"]
             page.Freeze()
             try:
                 for p in page.plugins: p.render(reparse=True)
                 page.SendSizeEvent()
@@ -675,24 +707,34 @@
         do, undo = (functools.partial(switch, x) for x in (p2, p1))
         page.undoredo.Submit(GenericCommand(do, undo, cname))
 
 
     def on_savefile_page_event(self, event):
         """Handler for notification from SavefilePage, updates UI."""
         page, idx = event.source, self.notebook.GetPageIndex(event.source)
+
+        if all(getattr(event, k, None) for k in ("plugin", "load")) and "hero" == event.plugin:
+            item = [event.load, page.filename]
+            self.history_hero.AddItem(item)
+            util.add_unique(conf.RecentHeroes, item, -1, conf.MaxRecentHeroes)
+            conf.save()
+            return
+
         ready, modified, rename = (getattr(event, x, None) for x in ("ready", "modified", "rename"))
         filename1, filename2 = (getattr(event, x, None) for x in ("filename1", "filename2"))
 
         if filename1 and filename2 and filename1 in self.files:
             self.files[filename2] = self.files.pop(filename1)
             self.files[filename2]["filename"] = filename2
 
         if ready or rename: self.update_notebook_header()
 
         self.update_fileinfo()
+        self.menu_changes.Enabled = page.get_unsaved()
+        self.menu_history.Enabled = bool(page.undoredo.Commands)
 
         if modified is not None or rename:
             suffix = "*" if modified else ""
             title1 = not rename and self.files[event.source.filename].get("title") \
                      or self.get_unique_tab_title(event.source.filename)
             self.files[event.source.filename]["title"] = title1
             title2 = title1 + suffix
@@ -703,47 +745,78 @@
 
 
     def on_undo_savefile(self, event=None):
         """Handler for clicking undo, invokes current page CommandProcessor."""
         page = self.notebook.GetCurrentPage()
         if not isinstance(page, SavefilePage) and len(self.files) == 1:
             page = next(iter(self.files.values()))["page"]
-        if isinstance(page, SavefilePage): page.undoredo.Undo()
+        if isinstance(page, SavefilePage) and page.undoredo.CanUndo():
+            guibase.status("Undoing %s" % page.undoredo.CurrentCommand.Name, flash=True, log=True)
+            page.undoredo.Undo()
 
 
     def on_redo_savefile(self, event=None):
         """Handler for clicking redo, invokes current page CommandProcessor."""
         page = self.notebook.GetCurrentPage()
         if not isinstance(page, SavefilePage) and len(self.files) == 1:
             page = next(iter(self.files.values()))["page"]
-        if isinstance(page, SavefilePage): page.undoredo.Redo()
+        if isinstance(page, SavefilePage) and page.undoredo.CanRedo():
+            cmd = page.undoredo.CurrentCommand or page.undoredo.Commands[0]
+            guibase.status("Redoing %s" % cmd.Name, flash=True, log=True)
+            page.undoredo.Redo()
 
 
     def on_menu_backup(self, event):
         """Handler for clicking to toggle backup-option."""
         conf.Backup = event.IsChecked()
         conf.save()
 
 
     def on_menu_confirm(self, event):
         """Handler for clicking to toggle confirm-option."""
         conf.ConfirmUnsaved = event.IsChecked()
         conf.save()
 
 
-    def on_menu_populate(self, event):
-        """Handler for clicking to toggle populate-option."""
-        conf.Populate = event.IsChecked()
+    def on_clear_recent(self, event):
+        """Handler for clearing recent files and heroes list."""
+        while self.history_file.Count: self.history_file.RemoveFileFromHistory(0)
+        self.history_hero.Clear()
+        conf.RecentFiles, conf.RecentHeroes = [], []
         conf.save()
 
 
+    def on_show_changes(self, event=None):
+        """Handler for clicking to show unsaved changes, pops up info dialog."""        
+        page = self.notebook.GetCurrentPage()
+        if isinstance(page, SavefilePage): page.show_changes()
+
+
+    def on_open_history(self, event=None):
+        """Handler for clicking to show command history, pops up history dialog."""
+        page = self.notebook.GetCurrentPage()
+        if not isinstance(page, SavefilePage): return
+        dlg = controls.CommandHistoryDialog(self, page.undoredo)
+        if dlg.ShowModal() != wx.ID_OK: return
+
+        count, cando, do = dlg.GetSelection(), page.undoredo.CanUndo, page.undoredo.Undo
+        if count >= 0: cando, do = page.undoredo.CanRedo, page.undoredo.Redo
+        verb = "Undo" if count < 0 else "Redo"
+        guibase.status("%sing %s", verb, util.plural("action", abs(count)), flash=True, log=True)
+        for _ in range(abs(count)):
+            if not cando(): break  # for
+            cmd = page.undoredo.CurrentCommand or page.undoredo.Commands[0]
+            guibase.status("%sing %s", verb, cmd.Name, flash=True, log=True)
+            do()
+
+
     def on_about(self, event=None):
         """Handler for clicking "About program" menu, opens a small info frame."""
         maketext = lambda: step.Template(templates.ABOUT_HTML).expand()
-        controls.AboutDialog(self, "About %s" % conf.Title, maketext).ShowModal()
+        controls.HtmlDialog(self, "About %s" % conf.Title, maketext).ShowModal()
 
 
     def on_browse(self, event=None):
         """Handler for clicking Browse-button, opens file dialog."""
         if wx.ID_OK != self.dialog_browse.ShowModal(): return
         self.dir_ctrl.SetPath(self.dialog_browse.GetPath())
 
@@ -812,16 +885,24 @@
     def on_open_savefile_event(self, event):
         """Handler for OpenSavefileEvent, loads the event savefile."""
         self.load_savefile_pages([os.path.realpath(event.filename)])
 
 
     def on_recent_file(self, event):
         """Handler for clicking an entry in Recent Files menu."""
-        filename = self.history_file.GetHistoryFile(event.Id - wx.ID_FILE1)
+        filename = self.history_file.GetHistoryFile(event.Id - self.history_file.BaseId)
+        self.load_savefile_page(filename)
+
+
+    def on_recent_hero(self, event):
+        """Handler for clicking an entry in Recent Heroes menu."""
+        heroname, filename = self.history_hero.GetItem(event.Id - self.history_hero.BaseId)
         self.load_savefile_page(filename)
+        if filename in self.files:
+            self.files[filename]["page"].plugin_action("hero", load=heroname)
 
 
     def on_change_dir_ctrl(self, event):
         """Handler for selecting a file in dir list, refreshes file controls."""
         filename = event.EventObject.GetPath()
         self.text_file.Value = filename if os.path.isfile(filename) else ""
         self.button_open.Enable(os.path.isfile(filename))
@@ -849,20 +930,20 @@
         self.StatusBar.SetStatusText(sz, 1)
         self.StatusBar.SetStatusText(dt, 2)
 
 
     def on_open_current_savefile(self, event=None):
         """Handler for clicking to open selected file from dir list."""
         if os.path.isfile(self.dir_ctrl.GetPath()):
-            self.load_savefile_page(self.dir_ctrl.GetPath())
+            self.load_savefile_pages([self.dir_ctrl.GetPath()])
 
 
     def on_open_from_dir_ctrl(self, event):
         """Handler for clicking to open selected files from directory list."""
-        self.load_savefile_page(event.EventObject.GetPath())
+        self.load_savefile_pages([event.EventObject.GetPath()])
 
 
     def on_refresh_dir_ctrl(self, event):
         """Handler for pressing F5 on directory tab, refreshes contents."""
         event and event.Skip()
         if isinstance(event, wx.KeyEvent) and wx.WXK_F5 != event.KeyCode: return
         path = self.dir_ctrl.Path
@@ -1036,15 +1117,15 @@
         finally:
             self.Thaw()
             busy.Close()
 
 
     def save_file(self, rename=False):
         """Saves the file, under a new name if specified, returns success."""
-        filename1, filename2, tempname = self.filename, self.filename, None
+        filename1, filename2, tempname, error = self.filename, self.filename, None, None
 
         if rename:
             title = "Save %s as.." % os.path.split(self.filename)[-1]
             dialog = wx.FileDialog(self,
                 message=title, wildcard=metadata.wildcard(),
                 defaultDir=os.path.split(self.filename)[0],
                 defaultFile=os.path.basename(self.filename),
@@ -1054,17 +1135,15 @@
 
             filename2 = dialog.GetPath()
             if filename1 != filename2 and filename2 in conf.FilesOpen: return wx.MessageBox(
                 "%s is already open in %s." % (filename2, conf.Title),
                 conf.Title, wx.OK | wx.ICON_WARNING
             )
         rename = (filename1 != filename2)
-
-        logger.info("Saving %s as %s.", filename1, filename2) if rename \
-        else logger.info("Saving %s.", filename1)
+        logger.info("Saving %s%s.", filename1, " as %s" % filename2 if rename else "")
 
         if rename:
             # Use a tertiary file in case something fails
             fh, tempname = tempfile.mkstemp(".gm1")
             os.close(fh)
 
         try:
@@ -1074,43 +1153,44 @@
             try: os.unlink(tempname)
             except Exception: pass
             wx.MessageBox("Error saving %s as %s:\n\n%s" %
                           (filename1, filename2, util.format_exc(e)),
                           conf.Title, wx.OK | wx.ICON_ERROR)
             return
 
-        success, error = True, None
+        if conf.Backup and os.path.exists(filename2):
+            backupname = "%s.%s" % (filename2, datetime.datetime.now().strftime("%Y%m%d"))
+            if os.path.exists(backupname):
+               logger.info("Skipping saving backup file, %s already exists.", backupname) 
+            else:
+                logger.info("Saving backup file %s.", backupname)
+                try:
+                    shutil.copy(filename2, backupname)
+                except Exception as e:
+                    logger.warning("Error saving backup of %s as %s.",
+                                   filename2, backupname, exc_info=True)
+
         try:
             self.savefile.write(tempname)
         except Exception as e:
             logger.exception("Error saving changes in %s.", self.filename)
             error = "Error saving changes:\n\n%s" % util.format_exc(e)
 
-        if success and conf.Backup and os.path.exists(filename2):
-            dt = datetime.datetime.now().strftime("%Y%m%d")
-            backupname = util.unique_path("%s.%s" % (filename2, dt))
-            logger.info("Saving backup file %s.", backupname)
-            try:
-                shutil.copy(filename2, backupname)
-            except Exception as e:
-                logger.warning("Error saving backup of %s as %s.",
-                               filename2, backupname, exc_info=True)
-        if success and rename:
+        if not error and rename:
             try:
                 shutil.copy(tempname, filename2)
             except Exception as e:
                 error = "Error saving %s as %s:\n\n%s" % (filename, filename2, util.format_exc(e))
-                logger.exception("Error saving temporary file %s as %s.",
-                                 tempname, filename2)
+                logger.exception("Error saving temporary file %s as %s.", tempname, filename2)
 
         try: tempname and os.unlink(tempname)
         except Exception: pass
 
-        if not success:
-            if error: wx.MessageBox(error, conf.Title, wx.OK | wx.ICON_ERROR)
+        if error:
+            wx.MessageBox(error, conf.Title, wx.OK | wx.ICON_ERROR)
             return
 
         self.filename = self.savefile.filename = filename2
         try: self.savefile.read()
         except Exception: logger.warning("Error re-reading %s.", filename2, exc_info=True)
         if rename:
             evt = SavefilePageEvent(self.Id, source=self, rename=True,
@@ -1121,38 +1201,65 @@
         guibase.status("Saved %s." % filename2, flash=True)
         return True
 
 
     def load_data(self):
         """Loads data from our file."""
         if not self.plugins:
-            self.plugins = plugins.render(self.savefile, self.notebook, self.undoredo)
+            self.plugins = plugins.populate(self.savefile, self.notebook, self.undoredo)
+            if self.notebook.PageCount < 2:
+                tabarea = next((x for x in self.notebook.Children
+                                if isinstance(x, wx.lib.agw.labelbook.ImageContainer)), None)
+                tabarea and (tabarea.Hide(), self.notebook.Layout())
+            self.Refresh()
+            for p in self.plugins: p.render()
+            wx_accel.accelerate(self.notebook)
         evt = SavefilePageEvent(self.Id, source=self, modified=False)
         wx.PostEvent(self.Parent, evt)
 
 
+    def plugin_action(self, name, **kwargs):
+        """Sends action to plugin specified by name."""
+        plugin = next((p for p in self.plugins if p.name == name), None)
+        if plugin: plugin.action(**kwargs)
+
+
+    def show_changes(self):
+        """Shows unsaved changes in a popup dialog."""
+        title = "Changes in %s" % self.savefile.filename
+        content = "".join(p.get_changes() for p in self.plugins)
+        controls.HtmlDialog(self, title, content, style=wx.RESIZE_BORDER).ShowModal()
+
+
     def on_page_event(self, event):
         """Handler for notification from subtabs, updates UI if modified."""
         changed = self.savefile.is_changed()
-        evt = SavefilePageEvent(self.Id, source=self, modified=changed)
+        args = event.ClientData if isinstance(event.ClientData, dict) else {}
+        evt = SavefilePageEvent(self.Id, **dict(args, source=self, modified=changed))
         wx.PostEvent(self.Parent, evt)
 
 
 
 class GenericCommand(wx.Command):
     """Undoable-redoable action."""
 
     def __init__(self, do, undo, name=""):
         super(GenericCommand, self).__init__(canUndo=True, name=name)
         self._do, self._undo = do, undo
+        self._timestamp = time.time()
 
     def Do(self):   return bool(self._do())
 
     def Undo(self): return bool(self._undo())
 
+    @property
+    def Timestamp(self):
+        """Returns command creation timestamp, as UNIX epoch."""
+        return self._timestamp
+
 
 
 def build(plugin, panel):
     """
     Builds generic components into given panel according to plugin props,
     populated with plugin state.
     Returns a list of created controls, in similar structure as state.
@@ -1164,82 +1271,101 @@
     panel.Freeze()
     panel.DestroyChildren()
     sizer = wx.GridBagSizer(vgap=10, hgap=10)
     panel.SetScrollRate(0, 20)
     panel.Sizer = wx.BoxSizer(wx.HORIZONTAL)
     panel.Sizer.Add(sizer, border=10, proportion=1, flag=wx.ALL | wx.GROW)
 
-    def make_value_handler(ctrl, myprops, row, index=None):
-        name = myprops.get("name")
-        target = next((x for x in (row, state) if isinstance(x, (list, dict))), None)
-
-        key = myprops.get("name", index)
-        target = next((x for x in (row, state) if isinstance(x, (list, dict))), None)
-
+    def make_value_handler(ctrl, myprops, rowindex=None):
+        name, key = myprops.get("name"), myprops.get("name", rowindex)
 
         def on_do(ctrl, value):
             result = False
+            state  = plugin.state() if callable(getattr(plugin, "state", None)) else {}
+            row    = state[rowindex] if rowindex is not None and isinstance(state, list) else state
+            target = next((x for x in (row, state) if isinstance(x, (list, dict))), None)
             if None not in (key, target) and util.get(target, key) == value:
                 return result
             if callable(getattr(plugin, "on_change", None)):
                 result = plugin.on_change(myprops, row, ctrl, value)
             elif None not in (key, target):
                 target[key], result = value, True
             if result: plugin.parent.patch()
             return result
 
         def handler(event):
             ctrl, value = event.EventObject, event.EventObject.Value
-            cname = "set %s: %s %s" % (plugin.name, "" if name is None else name,
-                                       "<blank>" if value is False or value in ("", None) else value)
+            label = " ".join(map(str, filter(bool, [plugin.item(), plugin.name])))
+            namelbl = "" if rowindex is None else "slot %s" % rowindex
+            if name is not None: namelbl += (" " if namelbl else "") + name
+            valuelbl = "<blank>" if value is False or value in ("", None) else value
+            cname = "set %s: %s %s" % (label, namelbl, valuelbl)
+            logger.info("Setting %s: %s to %s.", label, namelbl, valuelbl)
             action = functools.partial(on_do, ctrl, value)
             plugin.parent.command(action, cname)
         return handler
 
     def make_move_handler(ctrl, index, direction):
         def on_do():
+            state = plugin.state() if callable(getattr(plugin, "state", None)) else {}
             index2 = index + direction
             state[index], state[index2] = state[index2], state[index]
             plugin.parent.patch()
             wx.PostEvent(panel, PluginEvent(panel.Id, action="render", name=plugin.name))
             return True
 
         def handler(event):
-            cname = "swap %s: #%s and #%s" % (plugin.name, index + 1, index + direction + 1)
+            label = " ".join(map(str, filter(bool, [plugin.item(), plugin.name])))
+            cname = "swap %s: #%s and #%s" % (label, index + 1, index + direction + 1)
+            logger.info("Swapping %s: #%s and #%s.", label, index + 1, index + direction + 1)
             plugin.parent.command(on_do, cname)
         return handler
 
     def make_add_handler(ctrl, myprops):
         def on_do(value):
+            state = plugin.state() if callable(getattr(plugin, "state", None)) else {}
             if callable(getattr(plugin, "on_add", None)): plugin.on_add(myprops, value)
             else: state.append({"name": value})
             plugin.parent.patch()
             wx.PostEvent(panel, PluginEvent(panel.Id, action="render", name=plugin.name))
             return True
 
         def handler(event):
             if not ctrl.Value: return
-            cname = "add %s: %s" % (plugin.name, ctrl.Value)
+            label = " ".join(map(str, filter(bool, [plugin.item(), plugin.name])))
+            cname = "add %s: %s" % (label, ctrl.Value)
+            logger.info("Adding %s: %s.", label, ctrl.Value)
             plugin.parent.command(functools.partial(on_do, ctrl.Value), cname)
         return handler
 
     def make_remove_handler(ctrl, index):
         def on_do():
+            state = plugin.state() if callable(getattr(plugin, "state", None)) else {}
             del state[index]
             plugin.parent.patch()
             wx.PostEvent(panel, PluginEvent(panel.Id, action="render", name=plugin.name))
             return True
 
         def handler(event):
+            state = plugin.state() if callable(getattr(plugin, "state", None)) else {}
             v = state[index]
             if isinstance(v, dict): v = v.get("name", v)
-            cname = "remove %s: %s" % (plugin.name, v)
+            label = " ".join(map(str, filter(bool, [plugin.item(), plugin.name])))
+            cname = "remove %s: %s" % (label, v)
+            logger.info("Removing %s: %s.", label, v)
             plugin.parent.command(on_do, cname)
         return handler
 
+    def make_info(prop, sizer, pos):
+        value = prop["info"](plugin, prop, state) if callable(prop["info"]) else prop["info"]
+        c = wx.StaticText(panel, label=value)
+        ColourManager.Manage(c, "ForegroundColour", wx.SYS_COLOUR_GRAYTEXT)
+        sizer.Add(c, pos=pos)
+        result["%s-info" % prop["name"]] = c
+
 
     count = 0
     BTN_WPLUS  = 0 if "nt" == os.name else 20
     SPIN_WPLUS = 0 if "nt" == os.name else 80
     for prop in props if isinstance(props, (list, tuple)) else [props]:
         if "itemlist" == prop.get("type"):
             values_present = []
@@ -1261,26 +1387,25 @@
                         if prop.get("nullable") and "" not in choices: choices = [""] + choices
                         if v and v not in choices: choices = [v] + choices
                         c = wx.ComboBox(panel, style=wx.CB_DROPDOWN | wx.CB_READONLY,
                                         name="%s_%s" % (plugin.name, i))
                         c.SetItems(choices)
                         if v is not None: c.Value = v
                         elif "" in choices: c.Value = ""
-                        c.Bind(wx.EVT_COMBOBOX, make_value_handler(c, itemprop, row, index=i))
+                        c.Bind(wx.EVT_COMBOBOX, make_value_handler(c, itemprop, rowindex=i))
                         bsizer.Add(c)
                     elif "number" == itemprop.get("type"):
                         c = wx.SpinCtrl(panel, name=itemprop["name"], size=(80 + SPIN_WPLUS, -1),
                                         style=wx.ALIGN_RIGHT)
                         rng = list(c.Range)
                         if "min" in itemprop: rng[0] = min(itemprop["min"], 2**30) # SpinCtrl limit
                         if "max" in itemprop: rng[1] = min(itemprop["max"], 2**30)
                         c.SetRange(*rng)
                         if itemprop["name"] in row: c.Value = row[itemprop["name"]]
-                        c.Bind(wx.EVT_TEXT,     make_value_handler(c, itemprop, row, index=i))
-                        c.Bind(wx.EVT_SPINCTRL, make_value_handler(c, itemprop, row, index=i))
+                        c.Bind(wx.EVT_TEXT, make_value_handler(c, itemprop, rowindex=i))
                         bsizer.Add(c)
                     elif "window" == itemprop.get("type"):
                         c = wx.Window(panel)
                         bsizer.Add(c)
 
                     if c:
                         if isinstance(row, dict) and "name" in itemprop:
@@ -1326,22 +1451,21 @@
             c2 = wx.SpinCtrl(panel, name=prop["name"], size=(80 + SPIN_WPLUS, -1),
                              style=wx.ALIGN_RIGHT)
             rng = list(c2.Range)
             if "min" in prop: rng[0] = min(prop["min"], 2**30) # SpinCtrl limit
             if "max" in prop: rng[1] = min(prop["max"], 2**30)
             c2.SetRange(*rng)
             c2.Value = state[prop["name"]]
-            c2.Bind(wx.EVT_TEXT,     make_value_handler(c2, prop, state))
-            c2.Bind(wx.EVT_SPINCTRL, make_value_handler(c2, prop, state))
+            c2.Bind(wx.EVT_TEXT,     make_value_handler(c2, prop))
+            c2.Bind(wx.EVT_SPINCTRL, make_value_handler(c2, prop))
 
-            bsizer = wx.BoxSizer(wx.HORIZONTAL)
-            bsizer.Add(c2)
-            sizer.Add(c1,     pos=(count, 0), flag=wx.ALIGN_CENTER_VERTICAL)
-            sizer.Add(bsizer, pos=(count, 1))
+            sizer.Add(c1, pos=(count, 0), flag=wx.ALIGN_CENTER_VERTICAL)
+            sizer.Add(c2, pos=(count, 1))
             result[prop["name"]] = c2
+            if "info" in prop: make_info(prop, sizer, (count, 2))
             count += 1
 
 
         elif "combo" == prop.get("type"):
             c1 = wx.StaticText(panel, label="%s: " % prop.get("label", prop["name"]),
                                name="%s_label" % prop["name"])
             c2 = wx.ComboBox(panel, style=wx.CB_DROPDOWN | wx.CB_READONLY, name=prop["name"])
@@ -1351,35 +1475,38 @@
             if isinstance(choices, dict):
                 choices = list(choices.values())
                 v = next((y for x, y in prop["choices"].items() if v == x), v)
             if prop.get("nullable") and "" not in choices: choices = [""] + choices
             if v and v not in choices: choices = [v] + choices
             c2.SetItems(choices)
             if v is not None: c2.Value = v
-            c2.Bind(wx.EVT_COMBOBOX, make_value_handler(c2, prop, state))
+            c2.Bind(wx.EVT_COMBOBOX, make_value_handler(c2, prop))
 
             sizer.Add(c1, pos=(count, 0), flag=wx.ALIGN_CENTER_VERTICAL)
             sizer.Add(c2, pos=(count, 1), flag=wx.GROW)
             result[prop["name"]] = c2
+            if "info" in prop: make_info(prop, sizer, (count, 2))
             count += 1
 
 
         elif "check" == prop.get("type"):
             c1 = wx.StaticText(panel, label="%s: " % prop.get("label", prop["name"]),
                                name="%s_label" % prop["name"])
             c2 = wx.CheckBox(panel, name=prop["name"])
 
             c2.Value = bool(state[prop["name"]])
-            c2.Bind(wx.EVT_CHECKBOX, make_value_handler(c2, prop, state))
+            c2.Bind(wx.EVT_CHECKBOX, make_value_handler(c2, prop))
 
             sizer.Add(c1, pos=(count, 0), flag=wx.ALIGN_CENTER_VERTICAL)
             sizer.Add(c2, pos=(count, 1))
             result[prop["name"]] = c2
+            if "info" in prop: make_info(prop, sizer, (count, 2))
             count += 1
 
+
         elif "label" == prop.get("type"):
             c = wx.StaticText(panel, label=prop.get("label", ""))
             ColourManager.Manage(c, "ForegroundColour", wx.SYS_COLOUR_GRAYTEXT)
             sizer.Add(c, pos=(count, 0), span=(1, 2))
             count += 1
```

## h3sed/images.py

```diff
@@ -2,15 +2,15 @@
 Contains embedded image and icon resources. Auto-generated.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     21.03.2020
-@modified    18.01.2022
+@modified    24.02.2023
 ------------------------------------------------------------------------------
 """
 try:
     import wx
     from wx.lib.embeddedimage import PyEmbeddedImage
 except ImportError:
     class PyEmbeddedImage(object):
@@ -199,14 +199,349 @@
     "cuO/bloIfH6uGWNoqe0cXqD1S6SbQGfKYgcijJblcer5s4vnedYkEMGmkGDlnGC5WjFATQIU"
     "Q+bK0oSm5t4SlcPMmaNFVrcCCY4dpxNKFdlBkgmJ7a7IWH2lU3JsRqbS604H41IbiBAVIOIa"
     "CEwFHCVHIBjXgEuqbqX1SCaVOQxPqzlGdS1pLhyr8w6cH00G3t+dsoKojxEGw5JALnUriU75"
     "bHpn1RP2n/B+SWBMag2ol2Nkfv8A3KAxCtlEjPsAAAAASUVORK5CYII="
 )
 
 
+"""Background pattern image for export HTML."""
+ExportBg = PyEmbeddedImage(
+    "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"
+    "N56gsTvt/wMHTAvqq/dmVgAAAABJRU5ErkJggg=="
+)
+
+
 """Icon for the Hero page in a savefile tab."""
 PageHero = PyEmbeddedImage(
     "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEoElEQVRYw+2Wf0yUdRzHX9/n"
     "AS9OOQVKCRINkRSl/BUyDdc0nYkup5FKy8RmrbA2Y8MllZqDVdrSOZouNy1n5fy1kEQq2RLj"
     "ODUz5or0Qn7IAeePe7iD447He7794c6tiXC69Ze8//luz/b9vN+fX+/vA/3ox4MOca8XFCEk"
     "wLJ5ChvXvondfpmGpjo0zc3az5vF/yYgSJw1U7KruIgGey1XtACDTT7aPT6utjRRa6+n3tnJ"
     "vh8CIccNC5X8vRWRbPpwI53+LtqcDq5oARouVdHYeB2AhJHxpKVPIw246Tsu958ILbmwUMkX"
```

## h3sed/main.py

```diff
@@ -4,19 +4,20 @@
 handles logging and status calls.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     14.03.2020
-@modified    19.01.2022
+@modified    20.03.2022
 ------------------------------------------------------------------------------
 """
 import argparse
 import gzip
+import locale
 import logging
 import os
 import sys
 import threading
 import traceback
 
 import wx
@@ -44,14 +45,19 @@
 
     def InitLocale(self):
         self.ResetLocale()
         if "win32" == sys.platform:  # Avoid dialog buttons in native language
             mylocale = wx.Locale(wx.LANGUAGE_ENGLISH_US, wx.LOCALE_LOAD_DEFAULT)
             mylocale.AddCatalog("wxstd")
             self._initial_locale = mylocale  # Override wx.App._initial_locale
+            # Workaround for MSW giving locale as "en-US"; standard format is "en_US".
+            # Py3 provides "en[-_]US" in wx.Locale names and accepts "en" in locale.setlocale();
+            # Py2 provides "English_United States.1252" in wx.Locale.SysName and accepts only that.
+            name = mylocale.SysName if sys.version_info < (3, ) else mylocale.Name.split("_", 1)[0]
+            locale.setlocale(locale.LC_ALL, name)
 
 
 def except_hook(etype, evalue, etrace):
     """Handler for all unhandled exceptions."""
     text = "".join(traceback.format_exception(etype, evalue, etrace)).strip()
     log = "An unexpected error has occurred:\n\n%s"
     logger.error(log, text)
```

## h3sed/metadata.py

```diff
@@ -3,18 +3,18 @@
 Constants, data store and savefile functionality.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     22.03.2020
-@modified    15.01.2022
+@modified    31.01.2023
 ------------------------------------------------------------------------------
 """
-from collections import defaultdict
+from collections import defaultdict, OrderedDict
 import copy
 import datetime
 import gzip
 import logging
 import os
 import sys
 
@@ -26,16 +26,19 @@
 
 
 """Blank value bytes."""
 Blank = b"\xFF"
 Null  = b"\x00"
 
 
-"""Hero primary attributes, in file order."""
-PrimaryAttributes = ["Attack", "Defense", "Spell Power", "Knowledge"]
+"""Hero primary attributes, in file order, as {name: label}."""
+PrimaryAttributes = OrderedDict([
+    ('attack', 'Attack'),      ('defense',   'Defense'),
+    ('power',  'Spell Power'), ('knowledge', 'Knowledge')
+])
 
 
 """Hero skills, in file order."""
 Skills = [
     "Pathfinding", "Archery", "Logistics", "Scouting", "Diplomacy", "Navigation",
     "Leadership", "Wisdom", "Mysticism", "Luck", "Ballistics", "Eagle Eye",
     "Necromancy", "Estates", "Fire Magic", "Air Magic", "Water Magic",
```

## h3sed/templates.py

```diff
@@ -3,23 +3,26 @@
 HTML templates.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     14.03.2020
-@modified    15.01.2022
+@modified    25.02.2023
 ------------------------------------------------------------------------------
 """
 
 # Modules imported inside templates:
-#from h3sed import conf
+#import datetime, difflib, json, sys, wx
+#from h3sed.lib.vendor import step
+#from h3sed.lib import util
+#from h3sed import conf, images, plugins, templates
 
 
-"""Text shown in Help -> About dialog (HTML content)."""
+"""HTML text shown in Help -> About dialog."""
 ABOUT_HTML = """<%
 import sys, wx
 from h3sed import conf
 %>
 <font size="2" face="{{ conf.HtmlFontName }}" color="{{ conf.FgColour }}">
 <table cellpadding="0" cellspacing="0"><tr><td valign="middle">
 <img src="memory:{{ conf.Title.lower() }}.png" /></td><td width="10"></td><td valign="center">
@@ -61,7 +64,674 @@
   <li>Nullsoft Scriptable Install System, <a href="https://nsis.sourceforge.net/"><font color="{{ conf.LinkColour }}">nsis.sourceforge.net</font></a></li>
   <li>PyInstaller, <a href="https://www.pyinstaller.org"><font color="{{ conf.LinkColour }}">pyinstaller.org</font></a></li>
 </ul>
 %endif
 
 </font>
 """
+
+
+"""
+HTML text shown for hero full character sheet, toggleable between unsaved changes view.
+
+@param   name     hero name
+@param   texts    [category current content, ]
+@param  ?texts0   [category original content, ] if any, to show changes against current
+@param  ?changes  show changes against current
+
+"""
+HERO_CHARSHEET_HTML = """<%
+import difflib, wx
+from h3sed.lib.vendor import step
+from h3sed import conf, templates
+COLOUR_DISABLED = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT).GetAsString(wx.C2S_HTML_SYNTAX)
+texts0 = isdef("texts0") and texts0 or []
+changes = isdef("changes") and changes
+%>
+<font face="{{ conf.HtmlFontName }}" color="{{ conf.FgColour }}">
+<table cellpadding="0" cellspacing="0" width="100%"><tr>
+  <td><b>{{ name }}{{ " unsaved changes" if changes else "" }}</b></td>
+%if texts0:
+  <td align="right">
+    <a href="{{ "normal" if changes else "changes" }}"><font color="{{ conf.LinkColour }}">{{ "Normal view" if changes else "Unsaved changes" }}</font></a>
+  </td>
+%endif
+</tr></table>
+<font size="2">
+%if changes:
+{{! step.Template(templates.HERO_DIFF_HTML, escape=True).expand(changes=list(zip(texts0, texts))) }}
+%else:
+<table cellpadding="0" cellspacing="0">
+    %for text in texts:
+        %for line in text.rstrip().splitlines():
+  <tr><td><code>{{! escape(line).rstrip().replace(" ", "&nbsp;") }}</code></td></tr>
+        %endfor
+    %endfor
+%endif
+</table>
+</font>
+</font>
+"""
+
+
+"""
+HTML text shown for hero unsaved changes diff.
+
+@param  ?name     hero name, if any
+@param   changes  [(category content1, category content2), ]
+"""
+HERO_DIFF_HTML = """<%
+import difflib
+from h3sed import conf
+%>
+<font face="{{ conf.HtmlFontName }}" color="{{ conf.FgColour }}">
+%if isdef("name") and name:
+<b>{{ name }}</b>
+%endif
+<font size="2"><table cellpadding="0" cellspacing="0">
+%for v1, v2 in changes:
+<%
+entries, entry = [], []
+for line in difflib.Differ().compare(v1.splitlines(), v2.splitlines()):
+    if line.startswith("  "):
+        if entry: entries.append(entry + [""])
+        entries.append((line, line))
+        entry = []
+    elif line.startswith("- "):
+        if entry: entries.append(entry + [""])
+        entry = [line]
+    elif line.startswith("+ "):
+        entries.append((entry or [""]) + [line])
+        entry = []
+if entry: entries.append(entry + [""])
+entries = [[escape(l[2:].rstrip()).replace(" ", "&nbsp;") for l in ll] for ll in entries]
+%>
+    %for i, (l1, l2) in enumerate(entries):
+        %if not i:
+    <tr><td colspan="2"><code>{{! l1 }}</code></td></tr>
+        %elif l1 == l2:
+    <tr><td><code>{{! l1 }}</code></td><td><code>{{! l2 }}</code></td></tr>
+        %else:
+    <tr><td bgcolor="{{ conf.DiffOldColour }}"><code>{{! l1 }}</code></td>
+        <td bgcolor="{{ conf.DiffNewColour }}"><code>{{! l2 }}</code></td></tr>
+        %endif
+    %endfor
+%endfor
+</table></font>
+</font>
+"""
+
+
+"""
+Text to search for filtering heroes index.
+
+@param   hero       Hero instance
+@param   pluginmap  {name: plugin instance}
+@param  ?category   category to produce if not all, or empty string for hero name only
+"""
+HERO_SEARCH_TEXT = """<%
+from h3sed import conf, metadata
+deviceprops = pluginmap["stats"].props()
+deviceprops = deviceprops[next(i for i, x in enumerate(deviceprops) if "spellbook" == x["name"]):]
+category = category if isdef("category") else None
+%>
+%if category is None or not category:
+{{ hero.name }}
+%endif
+%if category is None or "stats" == category:
+{{ hero.stats["level"] }}
+    %for name in metadata.PrimaryAttributes:
+{{ hero.basestats[name] }}
+    %endfor
+%endif
+%if category is None or "devices" == category:
+    %for prop in deviceprops:
+        %if hero.stats.get(prop["name"]):
+{{ prop["label"] if isinstance(hero.stats[prop["name"]], bool) else hero.stats[prop["name"]] }}
+        %endif
+    %endfor
+%endif
+%if category is None or "skills" == category:
+    %for skill in hero.skills:
+{{ skill["name"] }}: {{ skill["level"] }}
+    %endfor
+%endif
+%if category is None or "army" == category:
+    %for army in filter(bool, hero.army):
+{{ army["name"] }}: {{ army["count"] }}
+    %endfor
+%endif
+%if category is None or "spells" == category:
+    %for item in hero.spells:
+{{ item }}
+    %endfor
+%endif
+%if category is None or "artifacts" == category:
+    %for item in filter(bool, hero.artifacts.values()):
+{{ item }}
+    %endfor
+%endif
+%if category is None or "inventory" == category:
+    %for item in filter(bool, hero.inventory):
+{{ item }}
+    %endfor
+%endif
+"""
+
+
+"""
+HTML text shown in heroes index.
+
+@param   heroes      [Hero instance, ]
+@param   links       [link for hero, ]
+@param   count       total number of heroes
+@param   pluginmap   {name: plugin instance}
+@param  ?categories  {category: whether to show category columns} if not showing all
+@param  ?text        current search text if any
+"""
+HERO_INDEX_HTML = """<%
+from h3sed import conf, metadata
+deviceprops = pluginmap["stats"].props()
+deviceprops = deviceprops[next(i for i, x in enumerate(deviceprops) if "spellbook" == x["name"]):]
+categories = categories if isdef("categories") else None
+%>
+<font face="{{ conf.HtmlFontName }}" color="{{ conf.FgColour }}">
+%if heroes:
+<table>
+  <tr>
+    <th align="left" valign="bottom">Name</th>
+%if not categories or categories["stats"]:
+    <th align="left" valign="bottom">Level</th>
+    %for label in metadata.PrimaryAttributes.values():
+    <th align="left" valign="bottom">{{ label.split()[-1] }}</th>
+    %endfor
+%endif
+%if not categories or categories["devices"]:
+    <th align="left" valign="bottom">Devices</th>
+%endif
+%if not categories or categories["skills"]:
+    <th align="left" valign="bottom">Skills</th>
+%endif
+%if not categories or categories["army"]:
+    <th align="left" valign="bottom">Army</th>
+%endif
+%if not categories or categories["spells"]:
+    <th align="left" valign="bottom">Spells</th>
+%endif
+%if not categories or categories["artifacts"]:
+    <th align="left" valign="bottom">Artifacts</th>
+%endif
+%if not categories or categories["inventory"]:
+    <th align="left" valign="bottom">Inventory</th>
+%endif
+  </tr>
+%elif count and isdef("text") and text.strip():
+   <i>No heroes to display for "{{ text }}"</i>
+%else:
+   <i>No heroes to display.</i>
+%endif
+%for i, hero in enumerate(heroes):
+  <tr>
+    <td align="left" valign="top" nowrap><a href="{{ links[i] }}"><font color="{{ conf.LinkColour }}">{{ hero.name }}</font></a></td>
+%if not categories or categories["stats"]:
+    <td align="left" valign="top" nowrap>{{ hero.stats["level"] }}</td>
+    %for name in metadata.PrimaryAttributes:
+    <td align="left" valign="top" nowrap>{{ hero.basestats[name] }}</td>
+    %endfor
+%endif
+%if not categories or categories["devices"]:
+    <td align="left" valign="top" nowrap>
+    %for prop in deviceprops:
+        %if hero.stats.get(prop["name"]):
+        {{ prop["label"] if isinstance(hero.stats[prop["name"]], bool) else hero.stats[prop["name"]] }}<br />
+        %endif
+    %endfor
+    </td>
+%endif
+%if not categories or categories["skills"]:
+    <td align="left" valign="top" nowrap>
+    %for skill in hero.skills:
+    <b>{{ skill["name"] }}:</b> {{ skill["level"] }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["army"]:
+    <td align="left" valign="top" nowrap>
+    %for army in filter(bool, hero.army):
+    {{ army["name"] }}: {{ army["count"] }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["spells"]:
+    <td align="left" valign="top" nowrap>
+    %for item in hero.spells:
+    {{ item }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["artifacts"]:
+    <td align="left" valign="top" nowrap>
+    %for item in filter(bool, hero.artifacts.values()):
+    {{ item }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["inventory"]:
+    <td align="left" valign="top" nowrap>
+    %for item in filter(bool, hero.inventory):
+    {{ item }}<br />
+    %endfor
+    </td>
+  </tr>
+%endif
+%endfor
+%if heroes:
+</table>
+%endif
+</font>
+"""
+
+
+"""
+Text to provide for hero columns in CSV export.
+
+@param   hero       Hero instance
+@param   column     column to provide like "level" or "devices"
+@param   pluginmap  {name: plugin instance}
+"""
+HERO_EXPORT_CSV = """<%
+deviceprops = pluginmap["stats"].props()
+deviceprops = deviceprops[next(i for i, x in enumerate(deviceprops) if "spellbook" == x["name"]):]
+%>
+%if "name" == column:
+{{ hero.name }}
+%elif column in hero.stats:
+{{ hero.stats[column] }}
+%elif "devices" == column:
+    %for prop in deviceprops:
+        %if hero.stats.get(prop["name"]):
+{{ prop["label"] if isinstance(hero.stats[prop["name"]], bool) else hero.stats[prop["name"]] }}
+        %endif
+    %endfor
+%elif "skills" == column:
+    %for skill in hero.skills:
+{{ skill["name"] }}: {{ skill["level"] }}
+    %endfor
+%elif "army" == column:
+    %for army in filter(bool, hero.army):
+{{ army["name"] }}: {{ army["count"] }}
+    %endfor
+%elif "spells" == column:
+    %for item in hero.spells:
+{{ item }}
+    %endfor
+%elif "artifacts" == column:
+    %for slot, item in ((k, v) for k, v in hero.artifacts.items() if v):
+{{ slot }}: {{ item }}
+    %endfor
+%elif "inventory" == column:
+    %for item in filter(bool, hero.inventory):
+{{ item }}
+    %endfor
+%endif
+"""
+
+
+"""
+HTML text for exporting heroes to file.
+
+@param   heroes      [Hero instance, ]
+@param   pluginmap   {name: plugin instance}
+@param   savefile    metadata.Savefile instance
+@param   count       total number of heroes
+@param   categories  {category: whether to show category columns initially}
+"""
+HERO_EXPORT_HTML = """<%
+import datetime, json
+from h3sed.lib import util
+from h3sed import conf, images, metadata, plugins
+deviceprops = pluginmap["stats"].props()
+deviceprops = deviceprops[next(i for i, x in enumerate(deviceprops) if "spellbook" == x["name"]):]
+%><!DOCTYPE HTML><html lang="en">
+<head>
+  <meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
+  <meta name="Author" content="{{ conf.Title }}">
+  <title>Heroes of Might & Magic III - Savegame export - Heroes</title>
+  <link rel="shortcut icon" type="image/png" href="data:image/png;base64,{{! images.Icon_16x16_16bit.data }}">
+  <style>
+    * { font-family: Tahoma, "DejaVu Sans", "Open Sans", Verdana; color: black; font-size: 11px; }
+    body {
+      background-image: url("data:image/png;base64,{{! images.ExportBg.data }}");
+      margin: 0;
+      padding: 0;
+    }
+    a, a.visited {
+      color: blue;
+      text-decoration: none;
+    }
+    table { border-spacing: 2px; empty-cells: show; width: 100%; }
+    td, th { border: 1px solid #C0C0C0; padding: 5px; }
+    th { text-align: left; white-space: nowrap; }
+    td { vertical-align: top; }
+    td.index, th.index { color: gray; width: 10px; }
+    td.index { color: gray; text-align: right; }
+    a.sort { display: block; }
+    a.sort:hover { cursor: pointer; text-decoration: none; }
+    a.sort::after      { content: ""; display: inline-block; min-width: 6px; position: relative; left: 3px; top: -1px; }
+    a.sort.asc::after  { content: "↓"; }
+    a.sort.desc::after { content: "↑"; }
+    .hidden { display: none !important; }
+    #content {
+      background-color: white;
+      border-radius: 5px;
+      margin: 10px auto 0 auto;
+      max-width: fit-content;
+      overflow-x: auto;
+      padding: 20px;
+    }
+    #info {
+      margin-bottom: 10px;
+    }
+    #opts { display: flex; justify-content: space-between; margin-right: 2px; }
+    #toggles { display: flex; }
+    #toggles > label { display: flex; align-items: center; margin-right: 5px; }
+    #toggles > .last-child { margin-left: auto; }
+    #footer {
+      color: white;
+      padding: 10px 0;
+      text-align: center;
+    }
+    #overlay {
+      display: flex;
+      align-items: center;
+      bottom: 0;
+      justify-content: center;
+      left: 0;
+      position: fixed;
+      right: 0;
+      top: 0;
+      z-index: 10000;
+    }
+    #overlay #overshadow {
+      background: black;
+      bottom: 0;
+      height: 100%;
+      left: 0;
+      opacity: 0.5;
+      position: fixed;
+      right: 0;
+      top: 0;
+      width: 100%;
+    }
+    #overlay #overbox {
+      background: white;
+      opacity: 1;
+      padding: 10px;
+      z-index: 10001;
+      max-width: calc(100% - 2 * 10px);
+      max-height: calc(100% - 2 * 10px - 20px);
+      overflow: auto;
+      position: relative;
+    }
+    #overlay #overbox > a {
+      position: absolute;
+      right: 5px;
+      top: 2px;
+    }
+    #overlay #overcontent {
+      font-family: monospace;
+      white-space: pre;
+    }
+  </style>
+  <script>
+<%
+MULTICOLS = {"stats": [3, 4, 5, 6, 7]}
+colptr = 7 if categories["stats"] else 3  # 1: index 2: name
+%>
+  var CATEGORIES = {  // {category: [table column index, ]}
+%for i, (category, state) in enumerate(categories.items()):
+    %if state:
+    "{{ category }}": {{! MULTICOLS.get(category) or [colptr] }},
+    %endif
+<%
+colptr += state
+%>
+%endfor
+  };
+  var HEROES = [
+%for i, hero in enumerate(heroes):
+    {{! json.dumps(hero.yaml) }},
+%endfor
+  ];
+  var toggles = {
+%for category in (k for k, v in categories.items() if v):
+    "{{ category }}": true,
+%endfor
+  };
+  var SEARCH_DELAY = 200;  // Milliseconds to delay search after input
+  var searchText = "";
+  var searchTimer = null;
+
+
+  /** Schedules search after delay. */
+  var onSearch = function(evt) {
+    window.clearTimeout(searchTimer); // Avoid reacting to rapid changes
+
+    var mysearch = evt.target.value.trim();
+    if (27 == evt.keyCode) mysearch = evt.target.value = "";
+    var mytimer = searchTimer = window.setTimeout(function() {
+      if (mytimer == searchTimer && mysearch != searchText) {
+        searchText = mysearch;
+        doSearch("heroes", mysearch);
+      };
+      searchTimer = null;
+    }, SEARCH_DELAY);
+  };
+
+
+  /** Sorts table by column of given table header link. */
+  var onSort = function(link) {
+    var col = null;
+    var prev_col = null;
+    var prev_direction = null;
+    var table = link.closest("table");
+    var linklist = table.querySelector("tr").querySelectorAll("a.sort");
+    for (var i = 0; i < linklist.length; i++) {
+      if (linklist[i] == link) col = i;
+      if (linklist[i].classList.contains("asc") || linklist[i].classList.contains("desc")) {
+        prev_col = i;
+        prev_direction = linklist[i].classList.contains("asc");
+      };
+      linklist[i].classList.remove("asc");
+      linklist[i].classList.remove("desc");
+    };
+    var sort_col = col;
+    var sort_direction = (sort_col == prev_col) ? !prev_direction : true;
+    var rowlist = table.getElementsByTagName("tr");
+    var rows = [];
+    for (var i = 1, ll = rowlist.length; i != ll; rows.push(rowlist[i++]));
+    rows.sort(sortfn.bind(this, sort_col, sort_direction));
+    for (var i = 0; i < rows.length; i++) table.tBodies[0].appendChild(rows[i]);
+
+    linklist[sort_col].classList.add(sort_direction ? "asc" : "desc")
+    return false;
+  };
+
+
+  /** Shows or hides category columns. */
+  var onToggle = function(category, elem) {
+    toggles[category] = elem.checked;
+    CATEGORIES[category].forEach(function(col) {
+      document.querySelectorAll("#heroes > tbody > tr > :nth-child(" + col + ")").forEach(function(elem) {
+        toggles[category] ? elem.classList.remove("hidden") : elem.classList.add("hidden");
+      })
+    });
+    doSearch("heroes", searchText);
+  };
+
+
+  /** Filters table by given text, retaining row if all words find a match in row cells. */
+  var doSearch = function(table_id, text) {
+    var words = String(text).split(/\s/g).filter(Boolean);
+    var regexes = words.map(function(word) { return new RegExp(escapeRegExp(word), "i"); });
+    var table = document.getElementById(table_id);
+    table.classList.add("hidden");
+    var rowlist = table.getElementsByTagName("tr");
+    var HIDDENCOLS = Object.keys(CATEGORIES).reduce(function(o, v, i) {
+      if (!toggles[v]) Array.prototype.push.apply(o, CATEGORIES[v]);
+      return o;
+    }, [])
+    for (var i = 1, ll = rowlist.length; i < ll; i++) {
+      var matches = {};  // {regex index: bool}
+      var show = !words.length;
+      var tr = rowlist[i];
+      for (var j = 0, cc = tr.childElementCount; j < cc && !show; j++) {
+        var ctext = (HIDDENCOLS.indexOf(j + 1) < 0) ? tr.children[j].innerText : "";
+        ctext && regexes.forEach(function(rgx, k) { if (ctext.match(rgx)) matches[k] = true; });
+      };
+      show = show || regexes.every(function(_, k) { return matches[k]; });
+      tr.classList[show ? "remove" : "add"]("hidden");
+    };
+    table.classList.remove("hidden");
+  };
+
+
+  /** Returns string with special characters escaped for RegExp. */
+  var escapeRegExp = function(string) {
+    return string.replace(/[-[\]{}()*+!<=:?.\/\^$|#\s,]/g, "\$&");
+  };
+
+
+  /** Toggles modal dialog with hero charsheet. */
+  var showHero = function(index) {
+    document.getElementById("overcontent").innerText = HEROES[index];
+    document.getElementById("overlay").classList.toggle("hidden");
+  };
+
+
+  /** Returns comparison result of given children in a vs b. */
+  var sortfn = function(sort_col, sort_direction, a, b) {
+    var v1 = a.children[sort_col].innerText.toLowerCase();
+    var v2 = b.children[sort_col].innerText.toLowerCase();
+    var result = String(v1).localeCompare(String(v2), undefined, {numeric: true});
+    return sort_direction ? result : -result;
+  };
+
+
+  window.addEventListener("load", function() {
+    document.location.hash = "";
+    document.body.addEventListener("keydown", function(evt) {
+      if (evt.keyCode == 27 && !document.getElementById("overlay").classList.contains("hidden")) showHero();
+    });
+  });
+  </script>
+</head>
+<body>
+<div id="content">
+  <div id="info">
+  Source: <b>{{ savefile.filename }}</b><br />
+  Size: <b>{{ util.format_bytes(savefile.size) }}</b><br />
+  Game version: <b>{{ next((x["label"] for x in plugins.version.PLUGINS if x["name"] == savefile.version), "unknown") }}</b><br />
+  Heroes: <b>{{ len(heroes) if len(heroes) == count else "%s exported (%s total)" % (len(heroes), count) }}</b><br />
+  </div>
+
+<div id="opts">
+  <div id="toggles">
+%for category in (k for k, v in categories.items() if v):
+    <label for="toggle-{{ category }}" title="Show or hide {{ category }} column{{ "s" if "stats" == category else "" }}"><input type="checkbox" id="toggle-{{ category }}" onclick="onToggle('{{ category }}', this)" checked />{{ category.capitalize() }}</label>
+%endfor
+  </div>
+  <input type="search" placeholder="Filter heroes" title="Filter heroes on any matching text" onkeyup="onSearch(event)" onsearch="onSearch(event)">
+</div>
+<table id="heroes">
+  <tr>
+    <th class="index asc"><a class="sort asc" title="Sort by index" onclick="onSort(this)">#</a></th>
+    <th><a class="sort" title="Sort by name" onclick="onSort(this)">Name</a></th>
+%if not categories or categories["stats"]:
+    <th><a class="sort" title="Sort by level" onclick="onSort(this)">Level</a></th>
+    %for label in metadata.PrimaryAttributes.values():
+    <th><a class="sort" title="Sort by {{ label.lower() }}" onclick="onSort(this)">{{ label.split()[-1] }}</a></th>
+    %endfor
+%endif
+%if not categories or categories["devices"]:
+    <th><a class="sort" title="Sort by devices" onclick="onSort(this)">Devices</a></th>
+%endif
+%if not categories or categories["skills"]:
+    <th><a class="sort" title="Sort by skills" onclick="onSort(this)">Skills</a></th>
+%endif
+%if not categories or categories["army"]:
+    <th><a class="sort" title="Sort by army" onclick="onSort(this)">Army</a></th>
+%endif
+%if not categories or categories["spells"]:
+    <th><a class="sort" title="Sort by spells" onclick="onSort(this)">Spells</a></th>
+%endif
+%if not categories or categories["artifacts"]:
+    <th><a class="sort" title="Sort by artifacts" onclick="onSort(this)">Artifacts</a></th>
+%endif
+%if not categories or categories["inventory"]:
+    <th><a class="sort" title="Sort by inventory" onclick="onSort(this)">Inventory</a></th>
+%endif
+  </tr>
+
+%for i, hero in enumerate(heroes):
+  <tr>
+    <td class="index">{{ i + 1 }}</td>
+    <td><a href="#{{ hero.name }}" title="Show {{ hero.name }} character sheet" onclick="showHero({{ i }})">{{ hero.name }}</a></td>
+%if not categories or categories["stats"]:
+    <td>{{ hero.stats["level"] }}</td>
+    %for name in metadata.PrimaryAttributes:
+    <td>{{ hero.basestats[name] }}</td>
+    %endfor
+%endif
+%if not categories or categories["devices"]:
+    <td>
+    %for prop in deviceprops:
+        %if hero.stats.get(prop["name"]):
+        {{ prop["label"] if isinstance(hero.stats[prop["name"]], bool) else hero.stats[prop["name"]] }}<br />
+        %endif
+    %endfor
+    </td>
+%endif
+%if not categories or categories["skills"]:
+    <td>
+    %for skill in hero.skills:
+    <b>{{ skill["name"] }}:</b> {{ skill["level"] }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["army"]:
+    <td>
+    %for army in filter(bool, hero.army):
+    {{ army["name"] }}: {{ army["count"] }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["spells"]:
+    <td>
+    %for item in hero.spells:
+    {{ item }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["artifacts"]:
+    <td>
+    %for item in filter(bool, hero.artifacts.values()):
+    {{ item }}<br />
+    %endfor
+    </td>
+%endif
+%if not categories or categories["inventory"]:
+    <td>
+    %for item in filter(bool, hero.inventory):
+    {{ item }}<br />
+    %endfor
+    </td>
+  </tr>
+%endif
+%endfor
+
+</table>
+</div>
+<div id="footer">{{ "Exported with %s on %s." % (conf.Title, datetime.datetime.now().strftime("%d.%m.%Y %H:%M")) }}</div>
+<div id="overlay" class="hidden"><div id="overshadow" onclick="showHero()"></div><div id="overbox"><a href="" title="Close" onclick="showHero()">x</a><div id="overcontent"></div></div></div>
+</body>
+"""
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### html2text {}

```diff
@@ -1,14 +1,16 @@
 # -*- coding: utf-8 -*- """ HTML templates. -----------------------------------
 ------------------------------------------- This file is part of h3sed -
 Heroes3 Savegame Editor. Released under the MIT License. @created 14.03.2020
-@modified 15.01.2022 ----------------------------------------------------------
--------------------- """ # Modules imported inside templates: #from h3sed
-import conf """Text shown in Help -> About dialog (HTML content).""" ABOUT_HTML
-= """<% import sys, wx from h3sed import conf %>
+@modified 25.02.2023 ----------------------------------------------------------
+-------------------- """ # Modules imported inside templates: #import datetime,
+difflib, json, sys, wx #from h3sed.lib.vendor import step #from h3sed.lib
+import util #from h3sed import conf, images, plugins, templates """HTML text
+shown in Help -> About dialog.""" ABOUT_HTML = """<% import sys, wx from h3sed
+import conf %>
 [memory:{         {{ conf.Title }} version {{ conf.Version }}, {{ conf.VersionDate }}.
 {
 conf.Title.lower  © 2020, Erki Suurjaak. {{_conf.HomeUrl.replace("https://",_"").replace("http:/
 () }}.png]        /",_"")_}}
 
 
 Savefile editor for Heroes of Might and Magic III.
@@ -30,8 +32,133 @@
       'frozen', False) else "" }}, wxpython.org
 %if getattr(sys, 'frozen', False):
 
 Installer and binary executable created with:
     * Nullsoft Scriptable Install System, nsis.sourceforge.net
     * PyInstaller, pyinstaller.org
 %endif
- """
+ """ """ HTML text shown for hero full character sheet, toggleable between
+unsaved changes view. @param name hero name @param texts [category current
+content, ] @param ?texts0 [category original content, ] if any, to show changes
+against current @param ?changes show changes against current """
+HERO_CHARSHEET_HTML = """<% import difflib, wx from h3sed.lib.vendor import
+step from h3sed import conf, templates COLOUR_DISABLED =
+wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT).GetAsString
+(wx.C2S_HTML_SYNTAX) texts0 = isdef("texts0") and texts0 or [] changes = isdef
+("changes") and changes %>
+{{ name }}{{ " unsaved changes" if   if changes else "changes" }}">{{ "Normal
+changes else "" }}                 view" if changes else "Unsaved changes" }}
+%if changes: {{! step.Template(templates.HERO_DIFF_HTML, escape=True).expand
+(changes=list(zip(texts0, texts))) }} %else:
+{{! escape(line).rstrip().replace(" ", " ") }}
+ """ """ HTML text shown for hero unsaved changes diff. @param ?name hero name,
+if any @param changes [(category content1, category content2), ] """
+HERO_DIFF_HTML = """<% import difflib from h3sed import conf %>
+%if isdef("name") and name: {{ name }} %endif
+{{! l1 }}
+{{! l1 }} {{! l2 }}
+{{! l1 }} {{! l2 }}
+ """ """ Text to search for filtering heroes index. @param hero Hero instance
+@param pluginmap {name: plugin instance} @param ?category category to produce
+if not all, or empty string for hero name only """ HERO_SEARCH_TEXT = """<%
+from h3sed import conf, metadata deviceprops = pluginmap["stats"].props()
+deviceprops = deviceprops[next(i for i, x in enumerate(deviceprops) if
+"spellbook" == x["name"]):] category = category if isdef("category") else None
+%> %if category is None or not category: {{ hero.name }} %endif %if category is
+None or "stats" == category: {{ hero.stats["level"] }} %for name in
+metadata.PrimaryAttributes: {{ hero.basestats[name] }} %endfor %endif %if
+category is None or "devices" == category: %for prop in deviceprops: %if
+hero.stats.get(prop["name"]): {{ prop["label"] if isinstance(hero.stats[prop
+["name"]], bool) else hero.stats[prop["name"]] }} %endif %endfor %endif %if
+category is None or "skills" == category: %for skill in hero.skills: {{ skill
+["name"] }}: {{ skill["level"] }} %endfor %endif %if category is None or "army"
+== category: %for army in filter(bool, hero.army): {{ army["name"] }}: {{ army
+["count"] }} %endfor %endif %if category is None or "spells" == category: %for
+item in hero.spells: {{ item }} %endfor %endif %if category is None or
+"artifacts" == category: %for item in filter(bool, hero.artifacts.values()): {
+{ item }} %endfor %endif %if category is None or "inventory" == category: %for
+item in filter(bool, hero.inventory): {{ item }} %endfor %endif """ """ HTML
+text shown in heroes index. @param heroes [Hero instance, ] @param links [link
+for hero, ] @param count total number of heroes @param pluginmap {name: plugin
+instance} @param ?categories {category: whether to show category columns} if
+not showing all @param ?text current search text if any """ HERO_INDEX_HTML =
+"""<% from h3sed import conf, metadata deviceprops = pluginmap["stats"].props()
+deviceprops = deviceprops[next(i for i, x in enumerate(deviceprops) if
+"spellbook" == x["name"]):] categories = categories if isdef("categories") else
+None %>
+%if heroes:
+                     {{ label.split
+Name      Level      ()[-1] }}      Devices        Skills       Army        Spells       Artifacts             Inventory
+{         {          {              %for prop in   %for skill   %for army   %for item in %for item in filter   %for item in
+{         {          {              deviceprops:   in           in filter   hero.spells: (bool,                filter(bool,
+hero.name hero.stats hero.basestats %if            hero.skills: (bool,      {{ item }}   hero.artifacts.values hero.inventory):
+}}        ["level"]  [name] }}      hero.stats.get {{ skill     hero.army): %endfor      ()): {{ item }}       {{ item }}
+          }}                        (prop          ["name"] }}: {{ army                  %endfor               %endfor
+                                    ["name"]): {   {{ skill     ["name"]
+                                    { prop         ["level"] }} }}: {{ army
+                                    ["label"] if   %endfor      ["count"]
+                                    isinstance                  }}
+                                    (hero.stats                 %endfor
+                                    [prop
+                                    ["name"]],
+                                    bool) else
+                                    hero.stats
+                                    [prop["name"]]
+                                    }}
+                                    %endif %endfor
+%endif
+ """ """ Text to provide for hero columns in CSV export. @param hero Hero
+instance @param column column to provide like "level" or "devices" @param
+pluginmap {name: plugin instance} """ HERO_EXPORT_CSV = """<% deviceprops =
+pluginmap["stats"].props() deviceprops = deviceprops[next(i for i, x in
+enumerate(deviceprops) if "spellbook" == x["name"]):] %> %if "name" == column:
+{{ hero.name }} %elif column in hero.stats: {{ hero.stats[column] }} %elif
+"devices" == column: %for prop in deviceprops: %if hero.stats.get(prop
+["name"]): {{ prop["label"] if isinstance(hero.stats[prop["name"]], bool) else
+hero.stats[prop["name"]] }} %endif %endfor %elif "skills" == column: %for skill
+in hero.skills: {{ skill["name"] }}: {{ skill["level"] }} %endfor %elif "army"
+== column: %for army in filter(bool, hero.army): {{ army["name"] }}: {{ army
+["count"] }} %endfor %elif "spells" == column: %for item in hero.spells: {
+{ item }} %endfor %elif "artifacts" == column: %for slot, item in ((k, v) for
+k, v in hero.artifacts.items() if v): {{ slot }}: {{ item }} %endfor %elif
+"inventory" == column: %for item in filter(bool, hero.inventory): {{ item }}
+%endfor %endif """ """ HTML text for exporting heroes to file. @param heroes
+[Hero instance, ] @param pluginmap {name: plugin instance} @param savefile
+metadata.Savefile instance @param count total number of heroes @param
+categories {category: whether to show category columns initially} """
+HERO_EXPORT_HTML = """<% import datetime, json from h3sed.lib import util from
+h3sed import conf, images, metadata, plugins deviceprops = pluginmap
+["stats"].props() deviceprops = deviceprops[next(i for i, x in enumerate
+(deviceprops) if "spellbook" == x["name"]):] %>
+
+Source: {{ savefile.filename }}
+Size: {{ util.format_bytes(savefile.size) }}
+Game version: {{ next((x["label"] for x in plugins.version.PLUGINS if x["name"]
+== savefile.version), "unknown") }}
+Heroes: {{ len(heroes) if len(heroes) == count else "%s exported (%s total)" %
+(len(heroes), count) }}
+%for category in (k for k, v in categories.items() if v):
+ if "stats" == category else "" }}">*{{ category.capitalize() }} %endfor
+[Unknown INPUT type]
+#  Name      Level      {{ label.split Devices        Skills       Army        Spells       Artifacts             Inventory
+                        ()[-1] }}
+                                       %for prop in
+                                       deviceprops:
+                                       %if
+                                       hero.stats.get              %for army
+                                       (prop          %for skill   in filter
+{                                      ["name"]): {   in           (bool,
+{  {         {          {              { prop         hero.skills: hero.army): %for item in %for item in filter   %for item in
+i  {         {          {              ["label"] if   {{ skill     {{ army     hero.spells: (bool,                filter(bool,
++  hero.name hero.stats hero.basestats isinstance     ["name"] }}: ["name"]    {{ item }}   hero.artifacts.values hero.inventory):
+1  }}        ["level"]  [name] }}      (hero.stats    {{ skill     }}: {{ army %endfor      ()): {{ item }}       {{ item }}
+}}           }}                        [prop          ["level"] }} ["count"]                %endfor               %endfor
+                                       ["name"]],     %endfor      }}
+                                       bool) else                  %endfor
+                                       hero.stats
+                                       [prop["name"]]
+                                       }}
+                                       %endif %endfor
+{{ "Exported with %s on %s." % (conf.Title, datetime.datetime.now().strftime
+("%d.%m.%Y %H:%M")) }}
+x
+"""
```

## h3sed/etc/h3sed.ini

```diff
@@ -1,11 +1,11 @@
-# Heroes3 Savegame Editor 1.0 configuration written on 2022-01-12 11:05:53.
-[*]
-Backup = true
-ConfirmUnsaved = true
-ConsoleHistoryCommands = []
-GameVersion = "sod"
-Populate = true
-RecentFiles = []
-SelectedPath = null
-WindowPosition = null
-WindowSize = [600, 700]
+# Heroes3 Savegame Editor 1.6 configuration written on 2023-02-26 13:37:18.
+[*]
+Backup = true
+ConfirmUnsaved = true
+ConsoleHistoryCommands = []
+GameVersion = "sod"
+RecentFiles = []
+RecentHeroes = []
+SelectedPath = null
+WindowPosition = null
+WindowSize = [650, 700]
```

## h3sed/lib/controls.py

```diff
@@ -1,87 +1,56 @@
 # -*- coding: utf-8 -*-
 """
 Stand-alone GUI components for wx:
 
-- AboutDialog(wx.Dialog):
-  About-dialog using wx.HtmlWindow.
-
 - BusyPanel(wx.Window):
-  Primitive hover panel with a message that stays in the center of parent
-  window.
+  Primitive hover panel with a message that stays in the center of parent window.
 
 - ColourManager(object):
   Updates managed component colours on Windows system colour change.
 
+- CommandHistoryDialog(wx.Dialog):
+  Popup dialog for wx.CommandProcessor history, allows selecting a range to undo or redo.
+
+- HtmlDialog(wx.Dialog):
+  Popup dialog showing a wx.HtmlWindow.
+
+- ItemHistory(wx.Object):
+  Like wx.HileHistory but for any kind of items.
+
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     14.03.2020
-@modified    12.01.2022
+@modified    26.02.2023
 ------------------------------------------------------------------------------
 """
 import collections
+import datetime
 import os
+import time
 import webbrowser
 
 import wx
 import wx.html
 import wx.lib.agw.labelbook
 import wx.lib.gizmos
 import wx.lib.wordwrap
 
 
 try: text_types = (str, unicode)        # Py2
 except Exception: text_types = (str, )  # Py3
 
 
-class AboutDialog(wx.Dialog):
-
-    def __init__(self, parent, title, content):
-        wx.Dialog.__init__(self, parent, title=title,
-                           style=wx.CAPTION | wx.CLOSE_BOX)
-        html = self.html = wx.html.HtmlWindow(self)
-        self.content = content
-
-        html.SetPage(content() if callable(content) else content)
-        html.BackgroundColour = ColourManager.GetColour(wx.SYS_COLOUR_WINDOW)
-        html.Bind(wx.html.EVT_HTML_LINK_CLICKED,
-                  lambda e: webbrowser.open(e.GetLinkInfo().Href))
-
-        self.Sizer = wx.BoxSizer(wx.VERTICAL)
-        self.Sizer.Add(html, proportion=1, flag=wx.GROW)
-        sizer_buttons = self.CreateButtonSizer(wx.OK)
-        self.Sizer.Add(sizer_buttons, border=8, flag=wx.ALIGN_CENTER | wx.ALL)
-        self.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.OnSysColourChange)
-
-        self.Layout()
-        FRAMEH = 2 * wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_Y, self) + \
-                 wx.SystemSettings.GetMetric(wx.SYS_CAPTION_Y, self)
-        height = FRAMEH + html.VirtualSize[1] + sizer_buttons.Size[1] + 2*8
-        self.Size = self.MinSize = (max(400, self.Size[0]), height)
-        self.CenterOnParent()
-
-
-    def OnSysColourChange(self, event):
-        """Handler for system colour change, refreshes content."""
-        event.Skip()
-        def dorefresh():
-            if not self: return
-            self.html.SetPage(self.content() if callable(self.content) else self.content)
-            self.html.BackgroundColour = ColourManager.GetColour(wx.SYS_COLOUR_WINDOW)
-            self.html.ForegroundColour = ColourManager.GetColour(wx.SYS_COLOUR_BTNTEXT)
-        wx.CallAfter(dorefresh) # Postpone to allow conf to update
-
-
-
 class BusyPanel(wx.Window):
     """
-    Primitive hover panel with a message that stays in the center of parent
-    window.
+    Primitive hover panel with a message that stays in the center of parent window.
+
+    Acts as an auto-closing context manager.
     """
     FOREGROUND_COLOUR = wx.WHITE
     BACKGROUND_COLOUR = wx.Colour(110, 110, 110, 255)
     REFRESH_INTERVAL  = 500
 
     def __init__(self, parent, label):
         wx.Window.__init__(self, parent)
@@ -109,14 +78,24 @@
         self.CenterOnParent()
         self.Show()
         parent.Refresh()
         wx.Yield()
         timer.Start(self.REFRESH_INTERVAL)
 
 
+    def __enter__(self):
+        """Context manager entry, does nothing, returns self."""
+        return self
+
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        """Context manager exit, destroys panel."""
+        self.Close()
+
+
     def _OnDestroy(self, event):
         event.Skip()
         try: self._timer.Stop()
         except Exception: pass
 
 
     def Close(self):
@@ -256,7 +235,358 @@
     def UpdateControlColour(cls, ctrl, prop, colour):
         """Sets control property or invokes "Set" + prop."""
         mycolour = cls.GetColour(colour)
         if hasattr(ctrl, prop):
             setattr(ctrl, prop, mycolour)
         elif hasattr(ctrl, "Set" + prop):
             getattr(ctrl, "Set" + prop)(mycolour)
+
+
+
+class CommandHistoryDialog(wx.Dialog):
+    """
+    Popup dialog for wx.CommandProcessor history, allows selecting a range to undo or redo.
+
+    A "Time since" column is included in the history
+    if the commands in CommandProcessor have `Timestamp` attributes as UNIX epoch.
+    """
+
+    def __init__(self, parent, cmdproc, title="Command History", style=0):
+        wx.Dialog.__init__(self, parent, title=title,
+                           style=wx.CAPTION | wx.CLOSE_BOX | wx.RESIZE_BORDER | style)
+        self.edge = -1  # Choice index for first undo command
+        cmdpos = cmdproc.Commands.index(cmdproc.CurrentCommand) if cmdproc.CurrentCommand else None
+        if cmdpos is not None: self.edge = len(cmdproc.Commands) - cmdpos - 1
+        headertext, choices = self._MakeTexts(cmdproc)
+
+        label = wx.StaticText(self, label="Select command(s) to undo or redo:")
+        header = wx.StaticText(self)
+        listbox = wx.ListBox(self, choices=choices, style=wx.LB_MULTIPLE)
+        sizer_buttons = self.CreateButtonSizer(wx.OK | wx.CANCEL)
+
+        header.Label = headertext
+        okbutton = next(c for c in self.Children if isinstance(c, wx.Button) and wx.ID_OK == c.Id)
+        okbutton.Label = "Redo" if self.edge < 0 else "Undo"
+        self.listbox = listbox
+        self.okbutton = okbutton
+
+        self.Sizer = wx.BoxSizer(wx.VERTICAL)
+        self.Sizer.Add(label,         border=8, flag=wx.ALL)
+        self.Sizer.Add(header,        border=8, flag=wx.LEFT)
+        self.Sizer.Add(listbox,       border=8, flag=wx.LEFT | wx.RIGHT | wx.GROW, proportion=1)
+        self.Sizer.Add(sizer_buttons, border=8, flag=wx.ALL | wx.ALIGN_CENTER)
+        self.Layout()
+        self.Size = self.MinSize = (400, 250)
+
+        self._EnsureSelection()
+        listbox.SetFocus()
+        self.Bind(wx.EVT_LISTBOX, self._OnSelectChange, listbox)
+        self.Bind(wx.EVT_LISTBOX_DCLICK, self._OnSubmit, listbox)
+        self.CenterOnParent()
+
+
+    def GetSelection(self):
+        """Returns the number of entries selected, negative if Undo."""
+        sels = self.listbox.GetSelections()
+        return (1 if self.edge < 0 or sels[0] < self.edge else -1) * len(sels) if sels else 0
+
+
+    def _EnsureSelection(self, index=None):
+        """
+        Ensures a valid range of undo or redo entries being selected.
+
+        @param   index  listbox index changed
+        """
+        if index is None:
+            if self.edge >= 0: self.listbox.Select(self.edge)  # Select first undo
+            for i in range(self.listbox.Count) if self.edge < 0 else ():
+                self.listbox.Select(i)  # Select all redos if only redos
+        else:
+            rng = [self.edge, index]  # Undo range
+            if self.edge < 0 or index < self.edge:  # Redo range
+                rng = [index, self.listbox.Count - 1 if self.edge < 0 else self.edge - 1]
+            for i in range(self.listbox.Count):
+                (self.listbox.SetSelection if rng[0] <= i <= rng[1] else self.listbox.Deselect)(i)
+            self.okbutton.Label = "Redo" if self.edge < 0 or index < self.edge else "Undo"
+
+
+    def _MakeTexts(self, cmdproc):
+        """Returns a list of texts for populating command history listbox."""
+        choices = []
+        columns, maxwidths, now = ["Number", "", "Command"], {}, time.time()
+        has_stamps = cmdproc.Commands and all(
+            isinstance(getattr(x, "Timestamp", None), (int, float)) and x.Timestamp > 0
+            for x in cmdproc.Commands
+        )
+        if has_stamps: columns.insert(1, "Time since")
+        headertext, INTER = "", " " * 6
+        getw = lambda x: self.GetTextExtent(str(x))[0]
+        spacew = self.GetTextExtent(" ")[0]
+        for i, c in enumerate(columns):
+            inter = "" if not i else INTER + ("" if c else " " * int(getw("Undo") / spacew))
+            headertext += inter + c
+            maxwidths[i] = max(maxwidths.get(i, 0), getw(c))
+        for index, c in enumerate(x.Name for x in reversed(cmdproc.Commands)):
+            category = "Redo" if self.edge < 0 or index < self.edge else "Undo"
+            item = [len(cmdproc.Commands) - index, category, c]
+            if has_stamps:
+                cmd = cmdproc.Commands[len(cmdproc.Commands) - index - 1]
+                since = str(datetime.timedelta(seconds=int(now - cmd.Timestamp)))
+                item.insert(1, since[2:] if since.startswith("0:") else since)
+            text = ""
+            for i, (c, v) in enumerate(zip(columns, item)):
+                pad = " " * int((maxwidths[i] - getw(v)) / spacew) if i < len(columns) - 1 else ""
+                lpad, rpad = ("", pad) if i > 1 else (pad[:-1], " ")
+                text += ("%s%s%s%s" % (INTER if i else "", lpad, v, rpad))
+            choices.append(text)
+        return headertext, choices
+
+
+    def _OnSelectChange(self, event):
+        """Handler for changing selection, ensures a valid range is selected."""
+        self._EnsureSelection(event.Selection)
+
+
+    def _OnSubmit(self, event):
+        """Handler for double-clicking listbox, submits dialog."""
+        self.EndModal(wx.ID_OK)
+
+
+class HtmlDialog(wx.Dialog):
+    """Popup dialog showing a wx.HtmlWindow, with an OK-button."""
+
+    def __init__(self, parent, title, content, links=None, buttons=None, style=0):
+        """
+        @param   links    {href: page text to show or function(href) to invoke, text result shown}
+        @param   buttons  {label: function() to invoke}
+        """
+        wx.Dialog.__init__(self, parent, title=title, style=wx.CAPTION | wx.CLOSE_BOX | style)
+        self.html = None
+        self.content = content
+        self.links = links.copy() if isinstance(links, dict) else {}
+
+        wrapper = wx.ScrolledWindow(self) if style & wx.RESIZE_BORDER else None
+        html = self.html = wx.html.HtmlWindow(wrapper or self)
+
+        if wrapper:
+            wrapper.Sizer = wx.BoxSizer(wx.VERTICAL)
+            wrapper.Sizer.Add(html, proportion=1, flag=wx.GROW)
+        self.Sizer = wx.BoxSizer(wx.VERTICAL)
+        self.Sizer.Add(wrapper or html, proportion=1, flag=wx.GROW)
+        sizer_buttons = self.CreateButtonSizer(wx.OK)
+        for label, handler in buttons.items() if buttons else ():
+            button = wx.Button(self, label=label)
+            button.Bind(wx.EVT_BUTTON, lambda e, f=handler: handler())
+            sizer_buttons.Add(button, border=3, flag=wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER)
+        self.Sizer.Add(sizer_buttons, border=8, flag=wx.ALIGN_CENTER | wx.ALL)
+        self.Layout()
+
+        if callable(content): content = content()
+        html.SetPage(content)
+        contentwidth = html.VirtualSize[0]
+        if links:
+            for x in (x for x in links.values() if isinstance(x, str)):
+                html.SetPage(x)
+                contentwidth = max(contentwidth, html.VirtualSize[0])
+            html.SetPage(content)
+        html.BackgroundColour = ColourManager.GetColour(wx.SYS_COLOUR_WINDOW)
+        html.ForegroundColour = ColourManager.GetColour(wx.SYS_COLOUR_BTNTEXT)
+
+        html.Bind(wx.html.EVT_HTML_LINK_CLICKED, self.OnLink)
+        self.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.OnSysColourChange)
+
+        BARWH = [wx.SystemSettings.GetMetric(x, self) for x in (wx.SYS_HSCROLL_Y, wx.SYS_VSCROLL_X)]
+        MAXW = wx.Display(self).ClientArea.Size[0]
+        MAXH = (parent.TopLevelParent if parent else wx.Display(self).ClientArea).Size[1]
+        FRAMEH = 2 * wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_Y, self) + \
+                 wx.SystemSettings.GetMetric(wx.SYS_CAPTION_Y, self)
+        width = contentwidth + 2*BARWH[0]
+        height = FRAMEH + html.VirtualSize[1] + sizer_buttons.Size[1] + BARWH[1]
+        self.Size = min(width, MAXW - 2*BARWH[0]), min(height, MAXH - 2*BARWH[1])
+        self.MinSize = (400, 300)
+        self.CenterOnParent()
+
+
+    def OnLink(self, event):
+        """Handler for clicking a link, sets new content if registered link else opens webbrowser."""
+        href = event.GetLinkInfo().Href
+        if href in self.links:
+            page = self.links[href]
+            if callable(page): page = page(href) 
+            if isinstance(page, str):
+                bcol, fcol = event.EventObject.BackgroundColour, event.EventObject.ForegroundColour
+                event.EventObject.SetPage(page)
+                event.EventObject.BackgroundColour, event.EventObject.ForegroundColour = bcol, fcol
+        else: webbrowser.open(href)
+
+
+    def OnSysColourChange(self, event):
+        """Handler for system colour change, refreshes content."""
+        event.Skip()
+        def dorefresh():
+            if not self: return
+            self.html.SetPage(self.content() if callable(self.content) else self.content)
+            self.html.BackgroundColour = ColourManager.GetColour(wx.SYS_COLOUR_WINDOW)
+            self.html.ForegroundColour = ColourManager.GetColour(wx.SYS_COLOUR_BTNTEXT)
+        wx.CallAfter(dorefresh) # Postpone to allow conf to update
+
+
+class ItemHistory(wx.Object):
+    """Like wx.HileHistory but for any kind of items."""
+
+    def __init__(self, maxItems=9, baseId=None):
+        """
+        @param   maxItems  maximum number of items to retain in menu
+        @param   baseId    ID given to the first menu item
+        """
+        super(ItemHistory, self).__init__()
+        self._max       = max(0, maxItems)
+        self._baseId    = wx.NewIdRef().Id if baseId is None else baseId
+        self._formatter = lambda x: u"%s" % (x, )
+        self._items     = []
+        self._menus     = []  # [wx.Menu, ]
+        self._item_ids  = {}  # {wx.Menu: {Id: index}}
+
+
+    def UseMenu(self, menu):
+        """Adds given menu to the list of menus managed by this history object."""
+        if menu not in self._menus:
+            self._menus.append(menu)
+            menu.Bind(wx.EVT_MENU, self._OnMenuItem)
+            self.Populate()
+
+
+    def RemoveMenu(self, menu):
+        """Removes given menu from the list of menus managed by this history object."""
+        if menu in self._menus:
+            self._menus.remove(menu)
+            menu.Unbind(wx.EVT_MENU, handler=self._OnMenuItem)
+
+
+    def GetMenus(self):
+        """Returns the list of menus managed by this history object."""
+        return self._menus[:]
+    Menus = property(GetMenus)
+
+
+    def AddItem(self, item):
+        """Adds item to history, as latest (first position in menus), repopulates menus."""
+        if self._items and item == self._items[0]: return
+        if item in self._items: self._items.remove(item)
+        self._items.insert(0, item)
+        if self._max > len(self._items):
+            del self._items[self._max:]
+        self.Populate()
+
+
+    def RemoveItem(self, item):
+        """Removes item from history, repopulates menus."""
+        if item in self._items:
+            self._items.remove(item)
+            self.Populate()
+
+
+    def Clear(self):
+        """Removes all items from history and menu."""
+        self._items.clear()
+        self.Populate()
+
+
+    def GetCount(self):
+        """Returns the number of items currently in history."""
+        return len(self._items)
+    Count = property(GetCount)
+
+
+    def GetMaxItems(self):
+        """Returns the maximum number of items that can be stored."""
+        return self._max
+    def SetMaxItems(self, maxItems):
+        """Sets the maximum number of items that can be stored, repopulates menus if needed."""
+        self._max = max(0, maxItems)
+        if self._max > len(self._items):
+            del self._items[self._max:]
+            self.Populate()
+    MaxItems = property(GetMaxItems, SetMaxItems)
+
+
+    def GetBaseId(self):
+        """Returns the base identifier for menu items."""
+        return self._baseId
+    def SetBaseId(self, baseId):
+        """Sets the base identifier for menu items, repopulates menus if needed."""
+        if baseId is None: baseId = wx.NewIdRef().Id
+        if baseId != self._baseId:
+            self._baseId = baseId
+            self.Populate()
+    BaseId = property(GetBaseId, SetBaseId)
+
+
+    def GetItems(self):
+        """Returns current content items."""
+        return self._items[:]
+    def SetItems(self, items):
+        """Sets current content items, repopulates menus."""
+        self._items[:] = items
+        self.Populate()
+    Items = property(GetItems, SetItems)
+
+
+    def GetItem(self, index):
+        """Returns content item at specified index."""
+        return self._items[index]
+
+
+    def GetFormatter(self):
+        """Returns menu label formatter function."""
+        return self._hint
+    def SetFormatter(self, formatter):
+        """Sets menu label formatter function, as func(item), and repopulates menu."""
+        if formatter != self._formatter:
+            self._formatter = formatter
+            self.Populate()
+    Formatter = property(GetFormatter, SetFormatter)
+
+
+    def Populate(self):
+        """Clears and populates menus from current content items."""
+        for m in self._menus:
+            for x in m.MenuItems: m.Delete(x)
+        self._item_ids.clear()
+        for i, item in enumerate(self._items):
+            label = "&%s %s" % (i + 1, self._formatter(item))
+            for m in self._menus:
+                menuitem = m.Append(wx.ID_ANY, label)
+                self._item_ids.setdefault(m, {})[menuitem.Id] = i
+
+
+    def _OnMenuItem(self, event):
+        """Handler for clicking a menu item in an associated menu, fires EVT_MENU_RANGE."""
+        menu = event.EventObject
+        if event.Id not in self._item_ids.get(menu, {}): return
+        evtId = self._baseId + self._item_ids[menu][event.Id]
+        evt = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, evtId)
+        evt.EventObject = menu
+        wx.PostEvent(menu.Window, evt)
+
+
+
+def get_dialog_path(dialog):
+    """
+    Returns the file path chosen in FileDialog, adding extension if dialog result
+    has none even though a filter has been selected, or if dialog result has a
+    different extension than what is available in selected filter.
+    """
+    result = dialog.GetPath()
+
+    # "SQLite database (*.db;*.sqlite;*.sqlite3)|*.db;*.sqlite;*.sqlite3|All files|*.*"
+    wcs = dialog.Wildcard.split("|")
+    wcs = wcs[1::2] if len(wcs) > 1 else wcs
+    wcs = [[y.lstrip("*") for y in x.split(";")] for x in wcs] # [['.ext1', '.ext2'], ..]
+
+    extension = os.path.splitext(result)[-1].lower()
+    selexts = wcs[dialog.FilterIndex] if 0 <= dialog.FilterIndex < len(wcs) else None
+    if result and selexts and extension not in selexts and dialog.ExtraStyle & wx.FD_SAVE:
+        ext = next((x for x in selexts if "*" not in x), None)
+        if ext: result += ext
+
+    return result
```

## h3sed/lib/util.py

```diff
@@ -3,18 +3,20 @@
 Miscellaneous utility functions.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created     19.11.2011
-@modified    15.01.2022
+@modified    26.02.2023
 ------------------------------------------------------------------------------
 """
 import collections
+import codecs
+import csv
 import ctypes
 import datetime
 import locale
 import math
 import os
 import re
 import subprocess
@@ -29,14 +31,57 @@
 except Exception: int_types = (int, )   # Py3
 try: text_types = (str, unicode)        # Py2
 except Exception: text_types = (str, )  # Py3
 try: string_type = unicode              # Py2
 except Exception: string_type = str     # Py3
 
 
+class csv_writer(object):
+    """Convenience wrapper for csv.Writer, with Python2/3 compatbility."""
+
+    def __init__(self, file_or_name):
+        if isinstance(file_or_name, text_types):
+            self._name = file_or_name
+            self._file = open(self._name, "wb") if sys.version_info < (3, ) else \
+                         codecs.open(self._name, "w", "utf-8")
+        else:
+            self._name = None
+            self._file = file_or_name
+        # csv.excel.delimiter default "," is not actually used by Excel.
+        self._writer = csv.writer(self._file, csv.excel, delimiter=";")
+
+    def __enter__(self):
+        """Context manager entry, does nothing, returns self."""
+        return self
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        """Context manager exit, closes file."""
+        self.close()
+
+    def writerow(self, sequence=()):
+        """Writes a CSV record from a sequence of fields."""
+        REPLS = {"\r\n": "\r\n", "\r": "\r\n", "\n": "\r\n", "\x00": "\\x00", '"': '""', "'": "''"}
+        RGX = re.compile("|".join(map(re.escape, REPLS)))
+        QRGX = re.compile("|".join(map(re.escape, '",')))
+        values = []
+        for v in sequence:
+            if sys.version_info < (3, ):
+                v = to_unicode(v).encode("utf-8", "backslashreplace")
+            if isinstance(v, text_types) and RGX.search(v):
+                v = RGX.sub(lambda m: REPLS[m.group()], v)
+            if isinstance(v, text_types) and QRGX.search(v):
+                v = '"%s"' % v
+            values.append(v)
+        self._writer.writerow(values)
+
+    def close(self):
+        """Closes CSV file writer."""
+        if self._name: self._file.close()
+
+
 def m(o, name, case_insensitive=True):
     """Returns the members of the object or dict, filtered by name."""
     members = o.keys() if isinstance(o, dict) else dir(o)
     if case_insensitive:
         return [i for i in members if name.lower() in i.lower()]
     else:
         return [i for i in members if name in i]
@@ -52,19 +97,14 @@
     """
     Converts an unsigned integer to a bytearray of specified length.
     """
     fmt = {1: "<B", 2: "<H", 4: "<L", 8: "<Q"}[length]
     return bytearray(struct.pack(fmt, v))
 
 
-def safe_filename(filename):
-    """Returns the filename with characters like \:*?"<>| removed."""
-    return re.sub(r"[\/\\\:\*\?\"\<\>\|\x00-\x1f]", "", filename)
-
-
 def format_bytes(size, precision=2, max_units=True, with_units=True):
     """
     Returns a formatted byte size (e.g. "421.45 MB" or "421,451,273 bytes").
 
     @param   precision   number of decimals to leave after converting to
                          maximum units
     @param   max_units   whether to convert value to corresponding maximum
@@ -108,15 +148,15 @@
              single     prefix to use for word if count is 1, e.g. "a"
              sep        thousand-separator to use for count
              pref       prefix to prepend to count, e.g. "~150"
              suf        suffix to append to count, e.g. "150+"
     """
     count   = len(items) if hasattr(items, "__len__") else items or 0
     isupper = word[-1:].isupper()
-    suffix = "es" if word and word[-1:].lower() in "xyz" else "s" if word else ""
+    suffix = "es" if word and word[-1:].lower() in "oxyz" else "s" if word else ""
     if isupper: suffix = suffix.upper()
     if count != 1 and "y" == word[-1:].lower():
         word = word[:-1] + ("I" if isupper else "i")
     result = word + ("" if 1 == count else suffix)
     if numbers and items is not None:
         fmtcount = single if 1 == count else "".join([
             x + ("," if i and not i % 3 else "")
@@ -162,14 +202,38 @@
     """
     if not os.path.exists(filepath):
         return start_file(os.path.split(filepath)[0])
     try: subprocess.Popen('explorer /select, "%s"' % shortpath(filepath))
     except Exception: start_file(os.path.split(filepath)[0])
 
 
+def start_file(filepath):
+    """
+    Tries to open the specified file or directory in the operating system.
+
+    @return  (success, error message)
+    """
+    success, error = True, ""
+    try:
+        if "nt" == os.name:
+            try: os.startfile(filepath)
+            except WindowsError as e:
+                if 1155 == e.winerror: # ERROR_NO_ASSOCIATION
+                    cmd = "Rundll32.exe SHELL32.dll, OpenAs_RunDLL %s"
+                    os.popen(cmd % filepath)
+                else: raise
+        elif "mac" == os.name:
+            subprocess.call(("open", filepath))
+        elif "posix" == os.name:
+            subprocess.call(("xdg-open", filepath))
+    except Exception as e:
+        success, error = False, format_exc(e)
+    return success, error
+
+
 def add_unique(lst, item, direction=1, maxlen=sys.maxsize):
     """
     Adds the item to the list from start or end. If item is already in list,
     removes it first. If list is longer than maxlen, shortens it.
 
     @param   direction  side from which item is added, -1/1 for start/end
     @param   maxlen     maximum length list is allowed to grow to before
```

## h3sed/lib/vendor/step.py

```diff
@@ -60,15 +60,15 @@
         else:
             self.code = self._process(self._preprocess(self.template))
             Template.COMPILED_TEMPLATES[cache_key] = self.code
 
     def expand(self, namespace={}, **kw):
         """Return the expanded template string"""
         output = []
-        namespace.update(kw, **self.builtins)
+        namespace = dict(namespace or {}, **dict(kw, **self.builtins))
         namespace["echo"]  = lambda s: output.append(s)
         namespace["isdef"] = lambda v: v in namespace
 
         eval(compile(self.code, "<string>", "exec"), namespace)
         return self._postprocess("".join(map(to_unicode, output)))
 
     def stream(self, buffer, namespace={}, encoding="utf-8", **kw):
@@ -77,15 +77,15 @@
         def write_buffer(s, flush=False, cache=[""]):
             # Cache output as a single string and write to buffer.
             cache[0] += to_unicode(s)
             if flush and cache[0] or len(cache[0]) > 65536:
                 buffer.write(self._postprocess(cache[0]).encode(encoding))
                 cache[0] = ""
 
-        namespace.update(kw, **self.builtins)
+        namespace = dict(namespace or {}, **dict(kw, **self.builtins))
         namespace["echo"]  = write_buffer
         namespace["isdef"] = lambda v: v in namespace
 
         eval(compile(self.code, "<string>", "exec"), namespace)
         write_buffer("", flush=True) # Flush any last cached bytes
 
     def _preprocess(self, template):
```

## h3sed/plugins/__init__.py

```diff
@@ -50,26 +50,31 @@
 
     def set_data(self, data):
         '''Sets currently selected data (like a hero), on undo-redo.'''
 
     def patch(self):
         '''Serializes current state (like selected hero), and patches savefile binary.'''
 
+    def action(self, **kwargs):
+        '''Invokes plugin action, like (load='Adela').'''
+
+
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   14.03.2020
-@modified  18.01.2022
+@modified  20.02.2022
 ------------------------------------------------------------------------------
 """
 import os
 import glob
 import importlib
 import logging
+import time
 
 import wx
 
 from h3sed import conf
 from h3sed.lib import wx_accel
 
 logger = logging.getLogger(__package__)
@@ -102,17 +107,17 @@
     result.sort(key=lambda x: (x.get("index", 1), x["name"]))
     for p in result:
         logger.info("Loading plugin %s.%s.", basepackage, p["name"])
         if callable(getattr(p["module"], "init",  None)): p["module"].init()
     return result
 
 
-def render(savefile, notebook, commandprocessor):
+def populate(savefile, notebook, commandprocessor):
     """
-    Renders main plugin tabs, given savefile and plugins notebook.
+    Populates notebook with main plugin tabs, returns plugin instances.
 
     @return   [plugin instance, ..]
     """
     result = []
     for i, p in enumerate(PLUGINS):
         if not callable(getattr(p["module"], "factory", None)):
             continue # for i, p
@@ -122,19 +127,15 @@
             try:
                 icon = p["icon"]
                 if hasattr(icon, "Bitmap"): icon = icon.Bitmap
                 idx = notebook.GetImageList().Add(icon)
                 notebook.SetPageImage(i, idx)
             except Exception:
                 logger.warning("Failed to load plugin '%s' icon.", p["name"])
-        obj = p["module"].factory(savefile, panel, commandprocessor)
-        obj.render()
-        result.append(obj)
-
-    wx_accel.accelerate(notebook)
+        result.append(p["module"].factory(savefile, panel, commandprocessor))
     return result
 
 
 def adapt(source, category, value):
     """
     Runs value through adapt() of any and all plugins.
 
@@ -156,14 +157,15 @@
     def __init__(self, plugin, do, name=""):
         super(PluginCommand, self).__init__(canUndo=True, name=name)
         self._do = do
         self._done = False
         self._data1 = None
         self._data2 = None
         self._plugin = plugin
+        self._timestamp = time.time()
 
     def Do(self):
         if self._done:
             self._plugin.set_data(self._data2)
             self._plugin.render(reload=True)
             self._plugin.patch()
         else:
@@ -173,7 +175,12 @@
         return self._done
 
     def Undo(self):
         self._plugin.set_data(self._data1)
         self._plugin.render(reload=True)
         self._plugin.patch()
         return True
+
+    @property
+    def Timestamp(self):
+        """Returns command creation timestamp, as UNIX epoch."""
+        return self._timestamp
```

## h3sed/plugins/hero/__init__.py

```diff
@@ -16,38 +16,44 @@
     def props():
         '''
         Returns plugin props {name, ?label, ?index}.
         Label is used as plugin tab label, falling back to plugin name.
         Index is used for sorting plugins.
         '''
 
-    def factory(parent, hero, panel):
+    def factory(savefile, parent, panel):
         '''
         Returns new plugin instance, if plugin instantiable.
 
-        @param   parent  parent plugin (hero-plugin)
-        @param   hero    plugins.hero.Hero instance
-        @param   panel   wx.Panel for plugin render
+        @param   savefile  xx
+        @param   parent    parent plugin (hero-plugin)
+        @param   panel     metadata.Savefile instance
         '''
 
 
 Subplugin instances are expected to have the following API:
 
     def props(self):
         '''Optional. Returns props for subplugin, if using gui.build().'''
 
     def state(self):
         '''Optional. Returns subplugin state for gui.build().'''
 
+    def item(self):
+        '''Mandatory. Returns current hero.'''
+
     def load(self, hero, panel=None):
         '''Mandatory. Loads subplugin state from hero, optionally resetting panel.'''
 
     def load_state(self, state):
         '''Optional. Loads subplugin state from given data. Returns whether state changed.'''
 
+    def parse(self, hero):
+        '''Mandatory. Returns subplugin state parsed from hero bytearray.'''
+
     def serialize(self):
         '''Mandatory. Returns new hero bytearray from subplugin state.'''
 
     def render(self):
         '''
         Optional. Renders subplugin into panel given in factory(),
         if subplugin not renderable with gui.build().
@@ -66,35 +72,41 @@
         '''
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   14.03.2020
-@modified  18.01.2022
+@modified  28.02.2023
 ------------------------------------------------------------------------------
 """
+import collections
 import copy
 import functools
 import glob
 import importlib
 import json
 import logging
 import os
 import re
+import sys
 
 import yaml
 import wx
+import wx.html
+import wx.lib.agw.flatnotebook
 
 from h3sed import conf
 from h3sed import gui
 from h3sed import guibase
 from h3sed import images
 from h3sed import metadata
 from h3sed import plugins
+from h3sed import templates
+from h3sed.lib.vendor import step
 from h3sed.lib import controls
 from h3sed.lib import util
 from h3sed.lib import wx_accel
 
 logger = logging.getLogger(__package__)
 
 
@@ -164,44 +176,44 @@
 # Since savefile format is unknown, hero structs are identified heuristically,
 # by matching byte patterns.
 RGX_HERO = re.compile(b"""
     # There are at least 60 bytes more at front, but those can also include
     # hero biography, making length indeterminate.
     # Bio ends at position -32 from total movement point start.
     # If bio end position is \x00, then bio is empty, otherwise bio extends back
-    # until a 4-byte span giving bio length (which always ends with \x00
-    # because bio can't be gigabytes long).
+    # until a 4-byte span giving bio length (which always ends with \x00).
 
     .{4}                     #   4 bytes: movement points in total             000-003
     .{4}                     #   4 bytes: movement points remaining            004-007
     .{4}                     #   4 bytes: experience                           008-011
     [\x00-\x1C][\x00]{3}     #   4 bytes: skill slots used                     012-015
     .{2}                     #   2 bytes: spell points remaining               016-017
     .{1}                     #   1 byte:  hero level                           018-018
 
     .{63}                    #  63 bytes: unknown                              019-081
 
     .{28}                    #  28 bytes: 7 4-byte creature IDs                082-109
     .{28}                    #  28 bytes: 7 4-byte creature counts             110-137
 
                              #  13 bytes: hero name, null-padded               138-150
-    (?P<name>[^\x00-\x20,\xF0-\xFF].{12})
+    (?P<name>[^\x00-\x20,\xF0-\xFF].{11}\x00)
     [\x00-\x03]{28}          #  28 bytes: skill levels                         151-178
     [\x00-\x1C]{28}          #  28 bytes: skill slots                          179-206
     .{4}                     #   4 bytes: primary stats                        207-210
 
     [\x00-\x01]{70}          #  70 bytes: spells in book                       211-280
     [\x00-\x01]{70}          #  70 bytes: spells available                     281-350
 
                              # 152 bytes: 19 8-byte equipments worn            351-502
-                             # Blank spots:   FF FF FF FF 00 00 00 00
+                             # Blank spots:   FF FF FF FF XY XY XY XY
                              # Artifacts:     XY 00 00 00 FF FF FF FF
                              # Scrolls:       XY 00 00 00 00 00 00 00
-                             # Catapult etc:  XY 00 00 00 XY XY 00 00
-    ( ((.\x00{3}) | \xFF{4}) (\x00{4} | \xFF{4} | (.{2}\x00{2})) ){19}
+    (?P<artifacts>(          # Catapult etc:  XY 00 00 00 XY XY 00 00
+      (\xFF{4} .{4}) | (.\x00{3} (\x00{4} | \xFF{4})) | (.\x00{3}.{2}\x00{2})
+    ){19})
 
                              # 512 bytes: 64 8-byte artifacts in backpack      503-1014
     ( ((.\x00{3}) | \xFF{4}) (\x00{4} | \xFF{4}) ){64}
 
                              # 10 bytes: slots taken by combination artifacts 1015-1024
     .[\x00-\x01]{6}[\x00-\x02][\x00-\x01][\x00-\x05]
 """, re.VERBOSE | re.DOTALL)
@@ -223,123 +235,398 @@
 def factory(savefile, panel, commandprocessor):
     """Returns a new hero-plugin instance."""
     return HeroPlugin(savefile, panel, commandprocessor)
 
 
 
 class Hero(object):
-    """Container for all hero attributes."""
+    """
+    Container for all hero attributes.
+
+    Plugins will add their own specific attributes like `inventory`.
+    """
 
-    def __init__(self, name, bytes, span, savefile):
-        self.name     = name
-        self.bytes    = bytes
-        self.span     = span
-        self.savefile = savefile
+    def __init__(self, name, bytes, place, span, savefile):
+        self.name      = name
+        self.bytes     = bytes
+        self.place     = place
+        self.span      = span
+        self.savefile  = savefile
+        self.basestats = {}  # Primary attributes without artifact bonuses
+        self.yaml      = ""  # Data after first load or last change, as full hero charsheet YAML
+        self.yamls1    = []  # Data after first load, as [category YAML, ]
+        self.yamls2    = []  # Data after last change, as [category YAML, ]
+
+    def copy(self):
+        """Returns a copy of this hero."""
+        hero = Hero(self.name, self.bytes, self.place, self.span, self.savefile)
+        hero.update(self)
+        return hero
+
+    def update(self, hero):
+        """Replaces attributes on hero with copies from given hero."""
+        for k, v in vars(hero).items():
+            v2 = v if isinstance(v, metadata.Savefile) else copy.deepcopy(v)
+            setattr(self, k, v2)
 
     def get_bytes(self, original=False):
         """Returns hero bytearray, current or original."""
         if not original: return copy.copy(self.bytes)
         return bytearray(self.savefile.raw0[self.span[0]:self.span[1]])
 
+    def ensure_basestats(self, clear=False):
+        """Populates internal hero stats without artifacts, if not already populated."""
+        if clear: self.basestats.clear()
+        if self.basestats or not hasattr(self, "artifacts"): return
+        STATS = metadata.Store.get("artifact_stats", self.savefile.version)
+        diff = [0] * len(metadata.PrimaryAttributes)
+        for item in filter(STATS.get, self.artifacts.values()):
+            diff = [a + b for a, b in zip(diff, STATS[item])]
+        for k, v in zip(metadata.PrimaryAttributes, diff):
+            self.basestats[k] = self.stats[k] - v
+
+    def __eq__(self, other):
+        """Returns whether this hero is the same as given (same name and place)."""
+        return isinstance(other, Hero) and (self.name, self.place) == (other.name, other.place)
+
+    def __str__(self):
+        """Returns hero name."""
+        return self.name
+
 
 
 class HeroPlugin(object):
     """Encapsulates hero-plugin state and behaviour."""
 
+    """Milliseconds to wait after edit before applying search filter"""
+    SEARCH_INTERVAL = 300
+
+    """Hero index columns for toggling."""
+    INDEX_CATEGORIES = ["stats", "devices", "skills", "army", "spells", "artifacts", "inventory"]
+
 
     def __init__(self, savefile, panel, commandprocessor):
-        self.name = PROPS["name"]
-        self.savefile  = savefile
-        self._panel    = panel # wxPanel container for hero components
-        self._undoredo = commandprocessor # wx.CommandProcessor
-        self._plugins  = []    # [{name, label, instance, panel}, ]
-        self._heroes   = []    # [{name, span: (start, stop), bytes: bytearray()}, ]
-        self._tabs     = []    # [{name, }]
-        self._ctrls    = {}    # {name: wx.Control, }
-        self._hero     = None  # Currently selected Hero instance
-        self._pending  = None  # Hero selected but not yet loaded
+        self.name        = PROPS["name"]
+        self.savefile    = savefile
+        self._panel      = panel   # wxPanel container for plugin components
+        self._undoredo   = commandprocessor # wx.CommandProcessor
+        self._plugins    = []      # [{name, label, instance, panel}, ]
+        self._heroes     = []      # [Hero(name, bytes, place, span, ..), ] ordered by name
+        self._ctrls      = {}      # {name: wx.Control, }
+        self._pages      = {}      # {wx.Window from self._ctrls["tabs"]: hero index in self._heroes}
+        self._indexpanel = None    # Heroes index panel
+        self._hero       = None    # Currently selected Hero instance
+        self._heropanel  = None    # Container for hero components
+        self._pages_visited = []   # Visited tabs, as [hero index in self._heroes or None if index page]
+        self._ignore_events = False  # For ignoring change events from programmatic selections
+        self._index = {
+            "herotexts": [],       # [hero contents to search in, as [{category: plaintext}] ]
+            "html":      "",       # Current hero search results HTML
+            "text":      "",       # Current search text
+            "timer":     None,     # wx.Timer for filtering heroes index
+            "ids":       {},       # {category: wx ID for toolbar toggle}
+            "visible":   [],       # List of heroes visible
+            "toggles":   collections.OrderedDict(),  # {category: toggled state}
+        }
+        self._dialog_export = wx.FileDialog(panel, "Export heroes to file",
+            wildcard="CSV spreadsheet (*.csv)|*.csv|HTML document (*.html)|*.html",
+            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT | wx.FD_CHANGE_DIR | wx.RESIZE_BORDER
+        )
+        self._dialog_export.FilterIndex = 1
         self.parse(detect_version=True)
+        self.prebuild()
         panel.Bind(gui.EVT_PLUGIN, self.on_plugin_event)
 
 
-    def build(self):
-        """Builds UI components."""
-        self._panel.DestroyChildren()
-        label = wx.StaticText(self._panel, label="&Select hero:")
-        combo = wx.ComboBox(self._panel, style=wx.CB_DROPDOWN | wx.CB_READONLY)
-        tb    = wx.ToolBar(self._panel, style=wx.TB_FLAT | wx.TB_NODIVIDER)
-        nb    = wx.Notebook(self._panel)
+    def prebuild(self):
+        """Builds general UI components."""
+        self._panel.Freeze()
+        label  = wx.StaticText(self._panel, label="&Select hero:")
+        combo  = wx.ComboBox(self._panel, style=wx.CB_DROPDOWN | wx.CB_READONLY)
+        tbtop  = wx.ToolBar(self._panel, style=wx.TB_FLAT | wx.TB_NODIVIDER)
+        search = wx.SearchCtrl(self._panel)
+        tabs = wx.lib.agw.flatnotebook.FlatNotebook(self._panel,
+            agwStyle=wx.lib.agw.flatnotebook.FNB_DROPDOWN_TABS_LIST |
+                     wx.lib.agw.flatnotebook.FNB_MOUSE_MIDDLE_CLOSES_TABS |
+                     wx.lib.agw.flatnotebook.FNB_NO_NAV_BUTTONS |
+                     wx.lib.agw.flatnotebook.FNB_NO_TAB_FOCUS |
+                     wx.lib.agw.flatnotebook.FNB_NO_X_BUTTON |
+                     wx.lib.agw.flatnotebook.FNB_FF2)
+
+        indexpanel = self._indexpanel = wx.Panel(self._panel)
+
+        bmpx = wx.ArtProvider.GetBitmap(wx.ART_FILE_SAVE_AS, wx.ART_TOOLBAR, (16, 16))
+        tb_index = wx.ToolBar(indexpanel, style=wx.TB_FLAT | wx.TB_NODIVIDER | wx.TB_NOICONS | wx.TB_TEXT)
+        info = wx.StaticText(indexpanel)
+        export = wx.Button(indexpanel, label="Expo&rt")
+        export.SetBitmap(bmpx)
+        export.SetBitmapMargins(0, 0)
+        export.ToolTip = "Export heroes to HTML or CSV"
+        export.Bind(wx.EVT_BUTTON, self.on_export_heroes)
+
+        for category in self.INDEX_CATEGORIES:
+            b = tb_index.AddCheckTool(wx.ID_ANY, category.capitalize(), wx.NullBitmap,
+                                      shortHelp="Show or hide %s column%s" %
+                                                (category, "s" if "stats" == category else ""))
+            tb_index.ToggleTool(b.Id, conf.HeroToggles.get(category, True))
+            tb_index.Bind(wx.EVT_TOOL, self.on_toggle_category, id=b.Id)
+            self._index["ids"][category] = b.Id
+            self._index["toggles"][category] = conf.HeroToggles.get(category, True)
+        tb_index.Realize()
+
+        html = wx.html.HtmlWindow(self._indexpanel)
+        tabs.AddPage(wx.Window(tabs), " INDEX ")
+
+        search.SetDescriptiveText("Search heroes")
+        search.ShowSearchButton(True)
+        search.ShowCancelButton(True)
+        search.ToolTip = "Filter hero index on any matching text (%s-F)" % \
+                         ("Cmd" if "darwin" == sys.platform else "Ctrl")
+        search.Bind(wx.EVT_CHAR, self.on_search)
+        search.Bind(wx.EVT_TEXT, self.on_search)
+        search.Bind(wx.EVT_SEARCH, self.on_search)
+        controls.ColourManager.Manage(html, "ForegroundColour", wx.SYS_COLOUR_BTNTEXT)
+        controls.ColourManager.Manage(html, "BackgroundColour", wx.SYS_COLOUR_WINDOW)
+        html.Bind(wx.html.EVT_HTML_LINK_CLICKED,
+                  lambda e: self.select_hero(int(e.GetLinkInfo().Href)))
+        html.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.on_sys_colour_change)
+
+        tb = wx.ToolBar(self._panel, style=wx.TB_FLAT | wx.TB_NODIVIDER)
 
-        combo.SetItems([x.name for x in self._heroes])
-        combo.Value = self._hero.name if self._hero else ""
         combo.Bind(wx.EVT_COMBOBOX, self.on_select_hero)
 
-        bmp1 = wx.ArtProvider.GetBitmap(wx.ART_COPY,  wx.ART_TOOLBAR, (16, 16))
-        bmp2 = wx.ArtProvider.GetBitmap(wx.ART_PASTE, wx.ART_TOOLBAR, (16, 16))
-        tb.AddTool(wx.ID_COPY,  "", bmp1, shortHelp="Copy current hero data to clipboard")
-        tb.AddTool(wx.ID_PASTE, "", bmp2, shortHelp="Paste data from clipboard to current hero")
-        tb.EnableTool(wx.ID_COPY,  False)
-        tb.EnableTool(wx.ID_PASTE, False)
-        tb.Bind(wx.EVT_TOOL, self.on_copy_hero,  id=wx.ID_COPY)
-        tb.Bind(wx.EVT_TOOL, self.on_paste_hero, id=wx.ID_PASTE)
+        CTRL = "Cmd" if "darwin" == sys.platform else "Ctrl"
+        bmp1 = wx.ArtProvider.GetBitmap(wx.ART_FOLDER,      wx.ART_TOOLBAR, (16, 16))
+        bmp2 = wx.ArtProvider.GetBitmap(wx.ART_INFORMATION, wx.ART_TOOLBAR, (20, 20))
+        bmp3 = wx.ArtProvider.GetBitmap(wx.ART_COPY,        wx.ART_TOOLBAR, (20, 20))
+        bmp4 = wx.ArtProvider.GetBitmap(wx.ART_PASTE,       wx.ART_TOOLBAR, (20, 20))
+        tbtop.AddTool(wx.ID_OPEN, "", bmp1, shortHelp="Show savefile in folder")
+        tb.AddTool(wx.ID_INFO,    "", bmp2, shortHelp="Show hero full character sheet\t%s-I" % CTRL)
+        tb.AddSeparator()
+        tb.AddTool(wx.ID_COPY,    "", bmp3, shortHelp="Copy current hero data to clipboard")
+        tb.AddTool(wx.ID_PASTE,   "", bmp4, shortHelp="Paste data from clipboard to current hero")
+        tbtop.Bind(wx.EVT_TOOL, self.on_open_folder, id=wx.ID_OPEN)
+        tb.Bind(wx.EVT_TOOL,    self.on_charsheet,   id=wx.ID_INFO)
+        tb.Bind(wx.EVT_TOOL,    self.on_copy_hero,   id=wx.ID_COPY)
+        tb.Bind(wx.EVT_TOOL,    self.on_paste_hero,  id=wx.ID_PASTE)
+        self._panel.Bind(wx.EVT_MENU, self.on_charsheet, id=wx.ID_INFO)
+        tbtop.Realize()
         tb.Realize()
+        tb.Disable()
+        tb.Hide()
 
-        for p in self._plugins:
-            subpanel = p["panel"] = wx.ScrolledWindow(nb)
-            if p.get("instance"): p["instance"].load(self._hero, subpanel)
-            title = p.get("label", p["name"])
-            nb.AddPage(subpanel, title)
+        tabs.MinSize = -1, tabs.GetTabArea().MinSize[1]
+        tabs.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.on_change_page, tabs)
+        tabs.Bind(wx.lib.agw.flatnotebook.EVT_FLATNOTEBOOK_PAGE_CLOSING,
+                  self.on_close_page, tabs)
+        tabs.Bind(wx.lib.agw.flatnotebook.EVT_FLATNOTEBOOK_PAGE_DROPPED,
+                  self.on_dragdrop_page, tabs)
+        controls.ColourManager.Manage(tabs, "ActiveTabColour",        wx.SYS_COLOUR_WINDOW)
+        controls.ColourManager.Manage(tabs, "ActiveTabTextColour",    wx.SYS_COLOUR_BTNTEXT)
+        controls.ColourManager.Manage(tabs, "NonActiveTabTextColour", wx.SYS_COLOUR_BTNTEXT)
+        controls.ColourManager.Manage(tabs, "TabAreaColour",          wx.SYS_COLOUR_BTNFACE)
+        controls.ColourManager.Manage(tabs, "GradientColourBorder",   wx.SYS_COLOUR_BTNSHADOW)
+        controls.ColourManager.Manage(tabs, "GradientColourTo",       wx.SYS_COLOUR_ACTIVECAPTION)
+        controls.ColourManager.Manage(tabs, "ForegroundColour",       wx.SYS_COLOUR_BTNTEXT)
+        controls.ColourManager.Manage(tabs, "BackgroundColour",       wx.SYS_COLOUR_WINDOW)
+
+        indexpanel.Sizer = wx.BoxSizer(wx.VERTICAL)
+        sizer_opts = wx.BoxSizer(wx.HORIZONTAL)
+        sizer_labels = wx.BoxSizer(wx.VERTICAL)
+        sizer_labels.Add(tb_index)
+        sizer_labels.Add(info)
+        sizer_opts.Add(sizer_labels, border=5, flag=wx.BOTTOM)
+        sizer_opts.AddStretchSpacer()
+        sizer_opts.Add(export, border=5, flag=wx.BOTTOM | wx.ALIGN_BOTTOM)
+        indexpanel.Sizer.Add(html, border=10, flag=wx.LEFT | wx.RIGHT | wx.GROW, proportion=1)
+        indexpanel.Sizer.Add(sizer_opts, border=10, flag=wx.LEFT | wx.RIGHT | wx.GROW)
+
+        self._heropanel = wx.Panel(self._panel)
+        self._heropanel.Sizer = wx.BoxSizer(wx.VERTICAL)
 
         sizer = self._panel.Sizer = wx.BoxSizer(wx.VERTICAL)
-        sizer_top           = wx.BoxSizer(wx.HORIZONTAL)
-        sizer_top.Add(label, flag=wx.RIGHT | wx.ALIGN_CENTER, border=10)
-        sizer_top.Add(combo, flag=wx.GROW)
-        sizer_top.Add(tb, border=10, flag=wx.LEFT)
-        sizer.Add(sizer_top, border=10, flag=wx.LEFT | wx.TOP | wx.GROW)
-        sizer.Add(nb,        border=10, proportion=1, flag=wx.ALL | wx.GROW)
+        sizer_top = wx.BoxSizer(wx.HORIZONTAL)
+        sizer_top.Add(label,  border=10, flag=wx.RIGHT | wx.ALIGN_CENTER)
+        sizer_top.Add(combo,  border=5,  flag=wx.TOP  | wx.BOTTOM | wx.GROW)
+        sizer_top.Add(tbtop,  border=5,  flag=wx.LEFT | wx.TOP | wx.BOTTOM)
+        sizer_top.AddStretchSpacer()
+        sizer_top.Add(search, border=5, flag=wx.ALL, proportion=1)
+        sizer_top.AddSpacer(5)
+        sizer.Add(sizer_top,  border=10, flag=wx.LEFT | wx.GROW)
+        sizer.Add(tabs,       border=5,  flag=wx.BOTTOM | wx.GROW)
+        sizer.Add(indexpanel, border=5, flag=wx.GROW, proportion=1)
+        sizer.Add(tb,         border=10, flag=wx.LEFT)
+        sizer.Add(self._heropanel, border=5, flag=wx.TOP | wx.GROW, proportion=1)
+        self._panel.Bind(wx.EVT_CHAR_HOOK, self.on_key)
+        wx_accel.accelerate(self._panel, accelerators=[(wx.ACCEL_CMD, ord("I"), wx.ID_INFO)])
+        self._panel.Layout()
+        self._panel.Thaw()
 
+        self._ctrls["tabs"] = tabs
         self._ctrls["hero"] = combo
+        self._ctrls["search"] = search
+        self._ctrls["count"] = info
+        self._ctrls["html"] = html
         self._ctrls["toolbar"] = tb
-        wx_accel.accelerate(self._panel)
-        for p in self._plugins if self._hero else ():
-            self.render_plugin(p["name"])
-        if conf.Populate and self._heroes:
-            index = next((i for i, h in enumerate(self._heroes) if h is self._hero), 0)
-            self._hero = None
-            wx.CallAfter(lambda: self and (combo.SetSelection(index), self.on_select_hero(index=index)))
+
+
+    def build(self):
+        """Builds hero UI components."""
+        self._panel.Freeze()
+        self._heropanel.DestroyChildren()
+        self._heropanel.Sizer.Clear()
+        self._ctrls["hero"].SetItems([x.name for x in self._heroes])
+
+        nb = wx.Notebook(self._heropanel)
+        for p in self._plugins:
+            subpanel = p["panel"] = wx.ScrolledWindow(nb)
+            title = p.get("label", p["name"])
+            nb.AddPage(subpanel, title)
+        self._heropanel.Sizer.Add(nb, border=10, flag=wx.ALL ^ wx.TOP | wx.GROW, proportion=1)
+
+        self._heropanel.Hide()
+        self._panel.Thaw()
+        with controls.BusyPanel(self._panel, "Loading heroes."):
+            self.populate_index()
 
 
     def command(self, callable, name=None):
-        """"""
+        """Submits callable to undo-redo command processor to be invoked."""
+        if not self._panel: return
         self._undoredo.Submit(plugins.PluginCommand(self, callable, name))
+        wx.CallAfter(self.populate_index)
 
 
     def render(self, reparse=False, reload=False):
         """
         Renders hero selection and editing subtabs into our panel.
 
         @param   reparse  whether plugins should re-parse state from savefile
         @param   reload   whether plugins should reload state from hero
         """
-        if not PLUGINS: init()
-        self._plugins = self._plugins or [x.copy() for x in PLUGINS]
-        if reparse:
-            self.parse()
-            self._hero = self._hero and next((x for x in self._heroes
-                                              if self._hero.name == x.name), None)
-            self.build()
-        elif self._panel.Children and self._hero:
-            for p in self._plugins: self.render_plugin(p["name"], reload=reparse or reload)
+        if not self._plugins:
+            if not PLUGINS: init()
+            self._plugins = [x.copy() for x in PLUGINS]
+            for p in self._plugins:
+                p["instance"] = p["module"].factory(self.savefile, self, panel=None)
+        if reparse: self.reparse()
+        elif self._hero and self._heropanel.Children:
+            for p in self._plugins: self.render_plugin(p["name"], reload=reload)
         else: self.build()
 
 
+    def action(self, **kwargs):
+        """Handler for action (load=hero name or index)"""
+        if kwargs.get("load") is not None:
+            value = kwargs["load"]
+            if isinstance(value, int):
+                index = max(0, min(value, len(self._heroes) - 1))
+            else: index = next((i for i, x in enumerate(self._heroes) if x.name == value), -1)
+            if index >= 0 and self._heroes: self.select_hero(index)
+
+
+    def reparse(self):
+        """Reparses state from savefile and refreshes UI."""
+        tabs = self._ctrls["tabs"]
+        hero0 = self._hero if self._pages_visited[-1:] not in ([], [None]) else None
+        pages0 = [self._pages[p] for i in range(tabs.GetPageCount())
+                  for p in [tabs.GetPage(i)] if p in self._pages]  # [hero index, ]
+        heroes0  = self._heroes[:]
+        visited0 = self._pages_visited[:]
+        self._hero = None
+        self._pages.clear()
+        del self._pages_visited[:]
+        for k, v in list(self._index.items()):
+            if isinstance(v, (str, list)): self._index[k] = type(v)()
+
+        self.parse()
+        self._panel.Freeze()
+        self._ignore_events = True
+        try:
+            while tabs.GetPageCount() > 1: tabs.DeletePage(1)
+            self.build()
+            hero = None
+            for index in pages0:
+                hero1 = heroes0[index]
+                hero2 = index < len(self._heroes) and self._heroes[index]
+                if hero1 != hero2:
+                    hero2 = next((x for x in self._heroes if x == hero1), None)  # Match name+place
+                    hero2 = hero2 or next((x for x in self._heroes if x.name == hero1.name), None)
+                if not hero2:
+                    visited0 = [i for i in visited0 if i != index]
+                    continue  # for index
+                page = wx.Window(tabs)
+                self._pages[page] = index
+                if not hero and hero0 and hero2.name == hero0.name: hero = hero2
+                tabs.AddPage(page, hero2.name, select=hero2 is hero)
+
+            visited0 = [v for i, v in enumerate(visited0) if not i or v != visited0[i - 1]]
+            self._pages_visited[:] = visited0
+            if not hero and visited0[-1:] not in ([], [None]): hero = self._heroes[visited0[-1]]
+            index = next(i for i, x in enumerate(self._heroes) if x is hero) if hero else None
+            if index is not None: self.select_hero(index, status=False)
+            self._panel.Layout()
+        finally:
+            self._ignore_events = False
+            self._panel.Thaw()
+
+
+    def populate_index(self, focus=False, force=False):
+        """Populates heroes index page, filtered by current search if any."""
+        if not self._panel: return
+        html, searchtext = self._ctrls["html"], self._ctrls["search"].Value.strip()
+        if not force and self._index["text"] == searchtext and self._index["herotexts"]: return
+
+        heroes, links = self._heroes[:], list(range(len(self._heroes)))
+        plugins = {p["name"]: p["instance"] for p in self._plugins}
+        tpl = step.Template(templates.HERO_SEARCH_TEXT)
+        tplargs = dict(pluginmap=plugins, categories=self._index["toggles"])
+        maketexts = lambda h: {c: tpl.expand(hero=h, category=c, **tplargs).lower()
+                               for c in ([""] + self.INDEX_CATEGORIES)}
+        if not self._index["herotexts"]:
+            for p in self._plugins:
+                for hero, state in zip(heroes, p["instance"].parse(heroes)):
+                    setattr(hero, p["name"], state)
+            for hero in heroes:
+                hero.ensure_basestats()
+                self.serialize_yaml(hero)
+            self._index["herotexts"] = [maketexts(h) for h in heroes]
+        elif self._hero:
+            self._hero.ensure_basestats()
+            index = next(i for i, h in enumerate(self._heroes) if h == self._hero)
+            self._index["herotexts"][index] = maketexts(self._hero)
+
+        if searchtext:
+            words, herotexts = searchtext.strip().lower().split(), self._index["herotexts"]
+            texts = ["\n".join(t for c, t in tt.items() if not c or self._index["toggles"][c])
+                     for tt in herotexts]
+            matches = [(i, h) for i, (h, t) in enumerate(zip(heroes, texts))
+                       if all(w in t for w in words)]
+            links, heroes = zip(*matches) if matches else ([], [])
+        self._index["text"] = searchtext
+        self._index["visible"] = heroes
+        tplargs.update(dict(heroes=heroes, count=len(self._heroes), links=links, text=searchtext))
+        page = step.Template(templates.HERO_INDEX_HTML, escape=True).expand(**tplargs)
+        if page != self._index["html"]:
+            info = util.plural("hero", heroes) if len(heroes) == len(self._heroes) else \
+                   "%s visible (%s total)" % (util.plural("hero", heroes), len(self._heroes))
+            self._ctrls["count"].Label = info
+            self._index["html"] = page
+            html.SetPage(page)
+            html.Scroll(html.GetScrollPos(wx.HORIZONTAL), 0)
+            html.BackgroundColour = controls.ColourManager.GetColour(wx.SYS_COLOUR_WINDOW)
+            html.ForegroundColour = controls.ColourManager.GetColour(wx.SYS_COLOUR_BTNTEXT)
+        if focus:
+            self.select_index()
+
+
     def on_copy_hero(self, event=None):
         """Handler for copying a hero, adds hero data to clipboard."""
         if self._hero and wx.TheClipboard.Open():
-            d = wx.TextDataObject(self.serialize_yaml())
+            d = wx.TextDataObject(self._hero.yaml)
             wx.TheClipboard.SetData(d), wx.TheClipboard.Close()
             guibase.status("Copied hero %s data to clipboard.",
                            self._hero.name, flash=True, log=True)
 
 
     def on_paste_hero(self, event=None):
         """Handler for copying a hero, adds hero data to clipboard."""
@@ -352,253 +639,488 @@
             wx.TheClipboard.Close()
         if value:
             guibase.status("Pasting data to hero %s from clipboard.",
                            self._hero.name, flash=True, log=True)
             self.parse_yaml(value)
 
 
+    def on_open_folder(self, event=None):
+        """Opens folder to savefile location."""
+        util.select_file(self.savefile.filename)
+
+
+    def on_charsheet(self, event=None):
+        """Opens popup with full hero profile."""
+        tpl = step.Template(templates.HERO_CHARSHEET_HTML, escape=True)
+        texts, texts0 = self._hero.yamls2 or self._hero.yamls1, None
+        if self._hero.yamls2 and self._hero.yamls1 != self._hero.yamls2: texts0 = self._hero.yamls1 
+        tplargs = dict(name=self._hero.name, texts=texts, texts0=texts0)
+        content, content2 = tpl.expand(**tplargs), tpl.expand(changes=True, **tplargs)
+        links = {"normal": content, "changes": content2}
+        buttons = {"Copy data": self.on_copy_hero}
+        dlg = controls.HtmlDialog(self._panel.TopLevelParent, "Hero character sheet", content,
+                                  links=links, buttons=buttons, style=wx.RESIZE_BORDER)
+        wx.CallAfter(dlg.ShowModal)
+
+
     def on_plugin_event(self, event):
         """Handler for a plugin event like serialize or re-render."""
         action = getattr(event, "action", None)
         if "patch" == action:
             event.Skip()
             self.patch()
         if "render" == action and getattr(event, "name", None):
             event.Skip()
             self.render_plugin(event.name)
 
 
-    def on_select_hero(self, event=None, index=None):
-        """Handler for selecting a hero, populates tabs with hero data."""
-        if self._pending: return
-        if event: index = event.EventObject.Selection
+    def on_change_page(self, event):
+        """Handler for changing a page in the heroes notebook, loads hero data."""
+        if self._ignore_events or event.GetOldSelection() < 0: return
+        page = self._ctrls["tabs"].GetCurrentPage()
+        if page not in self._pages: self.select_index()
+        else: self.select_hero(self._pages[page], status=False)
+
+
+    def on_close_page(self, event):
+        """Handler for closing a hero page, selects a previous hero page, if any."""
+        if self._ignore_events: return
+        tabs = self._ctrls["tabs"]
+        page = tabs.GetPage(event.GetSelection())
+        if page not in self._pages:
+            event.Veto()  # Disallow closing index
+            return
+        page0 = tabs.GetCurrentPage()
+        index = next((i for p, i in self._pages.items() if p == page), 0)
+        self._pages.pop(page, None)
+        visited = [x for x in self._pages_visited if x != index]
+        self._pages_visited = [v for i, v in enumerate(visited) if not i or v != visited[i - 1]]
+        if page0 is page:  # Closed the active page
+            self._hero = None
+            if self._pages_visited[-1:] in ([], [None]): self.select_index()
+            else: self.select_hero(self._pages_visited[-1], status=False)
+
+
+    def on_dragdrop_page(self, event=None):
+        """Handler for dragging a page, keeps index-page first."""
+        tabs = self._ctrls["tabs"]
+        tabs.Freeze()
+        self._ignore_events = True
+        try:
+            cur_page = tabs.GetCurrentPage()
+            idx_index, idx_page = next((i, p) for i in range(tabs.GetPageCount())
+                                       for p in [tabs.GetPage(i)] if p not in self._pages)
+            if idx_index > 0:
+                text = tabs.GetPageText(idx_index)
+                tabs.RemovePage(idx_index)
+                tabs.InsertPage(0, page=idx_page, text=text)
+            if tabs.GetCurrentPage() != cur_page:
+                tabs.SetSelection(tabs.GetPageIndex(cur_page))
+        finally:
+            self._ignore_events = False
+            tabs.Thaw()
+
+
+    def on_key(self, event):
+        """Handler for pressing a key, focuses filter on Ctrl-F."""
+        event.Skip()
+        if event.KeyCode in [ord("F")] and event.CmdDown():
+            self._ctrls["search"].SetFocus()
+
+
+    def on_search(self, event):
+        """Handler for changing search text, filters heroes index after a delay."""
+        event.Skip()
+        self._index["timer"], _ = None, self._index["timer"] and self._index["timer"].Stop()
+        if getattr(event, "KeyCode", None) == wx.WXK_ESCAPE:
+            event.EventObject.Value = ""
+        self._index["timer"] = wx.CallLater(self.SEARCH_INTERVAL, self.populate_index, focus=True)
+
+
+    def on_select_hero(self, event):
+        """Handler for selecting a hero in combobox, populates tabs with hero data."""
+        index = event.EventObject.Selection
         hero2 = self._heroes[index] if index < len(self._heroes) else None
-        if self._hero and hero2 is self._hero: return
-        name = hero2.name if hero2 else event.EventObject.Value if event else None
         if not hero2:
-            wx.MessageBox("Hero '%s' not found." % name,
+            wx.MessageBox("Hero '%s' not found." % event.EventObject.Value,
                           conf.Title, wx.OK | wx.ICON_ERROR)
             return
+        self.select_hero(index, status=index not in self._pages.values())
+
+
+    def on_export_heroes(self, event):
+        """Handler for exporting heroes to file, opens file dialog and exports data."""
+        if not self._index["visible"]: return
+        basename = os.path.splitext(os.path.basename(self.savefile.filename))[0]
+        self._dialog_export.Filename = "Heroes from %s" % basename
+        if wx.ID_OK != self._dialog_export.ShowModal(): return
+
+        wx.YieldIfNeeded() # Allow dialog to disappear
+        path = controls.get_dialog_path(self._dialog_export)
+        guibase.status("Exporting %s..", path, flash=True)
+        plugins = {p["name"]: p["instance"] for p in self._plugins}
+        if self._dialog_export.FilterIndex:
+            tpl = step.Template(templates.HERO_EXPORT_HTML, strip=False, escape=True)
+            tplargs = dict(heroes=self._index["visible"], categories=self._index["toggles"],
+                           pluginmap=plugins, savefile=self.savefile, count=len(self._heroes))
+            with open(path, "wb") as f:
+                tpl.stream(f, **tplargs)
+        else:
+            COLS = ["name"]
+            for k in (k for k, v in self._index["toggles"].items() if v):
+                COLS.extend((["level"] + list(metadata.PrimaryAttributes)) if "stats" == k else [k])
+            tpl = step.Template(templates.HERO_EXPORT_CSV, strip=False)
+            with util.csv_writer(path) as f:
+                f.writerow([c.capitalize() for c in COLS])
+                for hero in self._index["visible"]:
+                    vv = [tpl.expand(hero=hero, column=c, pluginmap=plugins).strip() for c in COLS]
+                    f.writerow(vv)
+        guibase.status("Exported %s (%s).", path, util.format_bytes(os.path.getsize(path)),
+                       flash=True)
+        util.start_file(path)
+
+
+    def on_toggle_category(self, event):
+        """Handler for toggling a category in index toolbar, refreshes heroes index."""
+        category = next(k for k, v in self._index["ids"].items() if v == event.Id)
+        on = not self._index["toggles"][category]
+        self._index["toggles"][category] = on
+        self.populate_index(force=True)
+        conf.HeroToggles.pop(category, None) if on else conf.HeroToggles.update({category: False})
+
+
+    def on_sys_colour_change(self, event):
+        """Handler for system colour change, refreshes hero index HTML."""
+        event.Skip()
+        wx.CallAfter(lambda: self and self.populate_index())
+
+
+    def select_hero(self, index, status=True):
+        """
+        Populates panel with hero data and ensures hero tab focus.
+
+        @param   index     hero index in local structure
+        @param   status    whether to show status messages
+        """
+        if not self._panel: return
+        hero2 = self._heroes[index] if index < len(self._heroes) else None
+        if not hero2: return
+        if hero2 is self._hero and index in self._pages.values():
+            self.select_hero_tab(index)
+            return
+
+        hero2.ensure_basestats()
+        combo, tabs, tb = self._ctrls["hero"], self._ctrls["tabs"], self._ctrls["toolbar"]
+        busy = controls.BusyPanel(self._panel, "Loading %s." % hero2.name) if status else None
+        if status: guibase.status("Loading %s.", hero2.name, flash=True)
+
+        self._ignore_events = True
+        self._panel.Freeze()
+        combo.SetSelection(index)
+        if index not in self._pages.values():
+            page = wx.Window(tabs)
+            self._pages[page] = index
+            changed = hero2.yamls2 and hero2.yamls1 != hero2.yamls2
+            title = "%s%s" % (hero2.name, "*" if changed else "")
+            tabs.AddPage(page, title, select=True)
+        else:
+            self.select_hero_tab(index)
 
-        def do():
-            if not self._panel: return
-            busy = controls.BusyPanel(self._panel, "Loading %s." % hero2.name)
-            if event: guibase.status("Loading %s." % hero2.name, flash=True)
-            self._panel.Freeze()
-            try:
-                if self._hero: self.patch()
-                logger.info("Loading hero %s (bytes %s-%s in savefile).",
-                            hero2.name, hero2.span[0], hero2.span[1] - 1)
-                self._hero = hero2
-                for p in self._plugins: self.render_plugin(p["name"], reload=True)
-            finally:
-                self._pending = None
-                self._ctrls["toolbar"].EnableTool(wx.ID_COPY,  True)
-                self._ctrls["toolbar"].EnableTool(wx.ID_PASTE, True)
-                self._panel.Thaw()
-                busy.Close()
-                if event: wx.CallLater(500, guibase.status, "")
-            return True
-        self._pending = hero2
-        if self._hero: wx.CallAfter(self.command, do, "select hero: %s" % hero2.name)
-        else: wx.CallAfter(do)
+        self._indexpanel.Hide()
+        self._heropanel.Show()
+        tb.Enable()
+        tb.Show()
+        try:
+            if self._hero: self.patch()
+            logger.info("Loading hero %s (bytes %s-%s in savefile).",
+                        hero2.name, hero2.span[0], hero2.span[1] - 1)
+            self._hero = hero2
+            for p in self._plugins: self.render_plugin(p["name"], reload=True)
+        finally:
+            if self._pages_visited[-1:] != [index]: self._pages_visited.append(index)
+            self._panel.Layout()
+            self._panel.Thaw()
+            self._ignore_events = False
+            if status: busy.Close(), wx.CallLater(500, guibase.status, "")
+            evt = gui.SavefilePageEvent(self._panel.Id)
+            evt.SetClientData(dict(plugin=self.name, load=hero2.name))
+            wx.PostEvent(self._panel, evt)
+
+
+    def select_hero_tab(self, index):
+        """Ensures hero tab is selected and hero panel shown."""
+        combo, tabs, tb = self._ctrls["hero"], self._ctrls["tabs"], self._ctrls["toolbar"]
+        page = next(p for p, i in self._pages.items() if i == index)
+        idx  = next(i for i in range(tabs.GetPageCount()) if page is tabs.GetPage(i))
+        if tabs.GetSelection() != idx: tabs.SetSelection(idx)
+        style = tabs.GetAGWWindowStyleFlag() | wx.lib.agw.flatnotebook.FNB_X_ON_TAB
+        if tabs.GetAGWWindowStyleFlag() != style: tabs.SetAGWWindowStyleFlag(style)
+        if not self._heropanel.Shown:
+            tb.Enable()
+            tb.Show()
+            self._indexpanel.Hide()
+            self._heropanel.Show()
+            self._panel.Layout()
+        if combo.Selection != index: combo.SetSelection(index)
+
+
+    def select_index(self):
+        """Switches to index page if not already there."""
+        combo, tabs, tb, search = (self._ctrls[k] for k in ("hero", "tabs", "toolbar", "search"))
+        searchsel = search.GetSelection()
+        focusctrl = self._panel.FindFocus()
+        combo, tabs, tb = self._ctrls["hero"], self._ctrls["tabs"], self._ctrls["toolbar"]
+        if tabs.GetSelection(): tabs.SetSelection(0)
+        style = tabs.GetAGWWindowStyleFlag() & (~wx.lib.agw.flatnotebook.FNB_X_ON_TAB)
+        if tabs.GetAGWWindowStyleFlag() != style: tabs.SetAGWWindowStyleFlag(style)
+        if not self._indexpanel.Shown:
+            tb.Hide()
+            tb.Disable()
+            self._heropanel.Hide()
+            self._indexpanel.Show()
+            self._panel.Layout()
+        if combo.Selection >= 0: combo.SetSelection(-1)
+        if self._pages_visited[-1:] != [None]: self._pages_visited.append(None)
+        if focusctrl is search and not search.HasFocus():
+            search.SetFocus()
+            search.SetSelection(*searchsel)
 
 
     def parse(self, detect_version=False):
         """
         Populates the list of hero bytearrays parsed from savefile binary,
         as [{"name": hero name, "bytes": bytearray()}], sorted by name.
 
         @param   detect_version  whether to try parsing with all version plugins
                                  instead of savefile current
         """
-        result, raw = [], self.savefile.raw
+        heroes = []
 
         ver0 = self.savefile.version
         versions, version_results = [], {}
         if detect_version and getattr(plugins, "version", None):
             versions = [x["name"] for x in plugins.version.PLUGINS]
         if not versions: versions = [self.savefile.version]
         all_versions = versions[:]
-        rgx_strip = re.compile(br"[\x00-\x19]")
+        rgx_strip = re.compile(br"^([^\x00-\x19,\xF0-\xFF]+)\x00+$")
+        rgx_nulls = re.compile(br"^(\x00+)|(\x00{4}\xFF{4})+$")
 
         while versions:
             ver = versions.pop()
             self.savefile.version = ver
             RGX = plugins.adapt(self, "regex", RGX_HERO)
             vresult = version_results.setdefault(ver, [])
 
             pos = 10000 # Hero structs are more to the end of the file
-            m = re.search(RGX, raw[pos:])
-            while m and rgx_strip.sub(b"", m.group("name")):
+            m = re.search(RGX, self.savefile.raw[pos:])
+            while m:
                 start, end = m.span()
-                blob = bytearray(raw[pos + start:pos + end])
-                vresult.append(Hero(util.to_unicode(rgx_strip.sub(b"", m.group("name"))),
-                                    blob, tuple(x + pos for x in m.span()),
-                                    self.savefile))
-                pos += start + len(blob)
-                m = re.search(RGX, raw[pos:])
+                if rgx_strip.match(m.group("name")) and not rgx_nulls.match(m.group("artifacts")):
+                    blob = bytearray(self.savefile.raw[pos + start:pos + end])
+                    name = util.to_unicode(rgx_strip.match(m.group("name")).group(1))
+                    hero = Hero(name, blob, len(vresult), (start + pos, end + pos), self.savefile)
+                    vresult.append(hero)
+                    pos += end
+                else:
+                    pos += start + 1
+                m = re.search(RGX, self.savefile.raw[pos:])
             if not vresult:
                 logger.warning("No heroes detected in %s as version '%s'.",
                                self.savefile.filename, ver)
                 continue  # while versions
             logger.info("Detected %s heroes in %s as version '%s'.",
                         len(vresult), self.savefile.filename, ver)
 
         vcounts = {k: len(v) for k, v in version_results.items()}
         maxcount_vers = [k for k in all_versions if vcounts[k] == max(vcounts.values())]
         ver = maxcount_vers[-1] if maxcount_vers else None
         if ver:
             self.savefile.version = ver
-            result = sorted(version_results[ver], key=lambda x: x.name.lower())
+            heroes = sorted(version_results[ver], key=lambda x: x.name.lower())
             logger.info("Interpreting %s as version '%s' with %s heroes.",
-                        self.savefile.filename, ver, len(result))
+                        self.savefile.filename, ver, len(heroes))
         else:
             self.savefile.version = ver0
             wx.CallAfter(guibase.status, "No heroes identified in %s.",
                          self.savefile.filename, flash=True, log=True)
 
-        self._heroes[:] = result
+        self._heroes[:] = heroes
 
 
     def parse_yaml(self, value):
         """Populates current hero with value parsed as YAML."""
         try:
             states = next(iter(yaml.safe_load(value).values()))
             assert isinstance(states, dict)
         except Exception as e:
-            logger.warn("Error loading hero data from clipboard: %s", e)
+            logger.warning("Error loading hero data from clipboard: %s", e)
             guibase.status("No valid hero data in clipboard.", flash=True)
             return
         pluginmap = {p["name"]: p["instance"] for p in self._plugins}
         usables = {}  # {plugin name: state}
         for category, state in states.items():
             plugin = pluginmap.get(category)
             if not callable(getattr(plugin, "load_state", None)):
                 continue  # for
             if not plugin:
-                logger.warn("Unknown category in hero data: %r", category)
+                logger.warning("Unknown category in hero data: %r", category)
                 continue  # for
             state0 = plugin.state()
             if state is None: state = type(state0)()
             if not isinstance(state0, type(state)):
-                logger.warn("Invalid data type in hero data %r for %s: %s",
-                            category, type(state0).__name__, state)
+                logger.warning("Invalid data type in hero data %r for %s: %s",
+                               category, type(state0).__name__, state)
                 continue  # for
             usables[category] = state
         if not usables: return
 
         def on_do(states):
-            pluginmap = {p["name"]: p["instance"] for p in self._plugins}
             changeds = []  # [plugin name, ]
+            pluginmap = {p["name"]: p["instance"] for p in self._plugins}
             for category, state in states.items():
                 plugin = pluginmap.get(category)
                 state0 = plugin.state()
                 if state is None: state = type(state0)()
                 if plugin.load_state(state): changeds.append(category)
+                setattr(self._hero, category, plugin.state())
+            self.serialize_yaml(self._hero, changes=True)
+            self._hero.ensure_basestats(clear=True)
             if changeds:
                 self.patch()
                 for name in changeds:
                     self.render_plugin(name)
             return bool(changeds)
+        self.command(functools.partial(on_do, usables), "paste hero data from clipboard")
 
-        cname = "paste hero data from clipboard"
-        self.command(functools.partial(on_do, usables), cname)
 
+    def serialize_yaml(self, hero, changes=False):
+        """
+        Sets hero data YAML attributes.
 
-    def serialize_yaml(self):
-        """Returns current hero data as YAML."""
+        @param   changes   whether to populate `yamls2` instead of `yamls1`
+        """
         LF, INDENT = os.linesep, "  "
-        maxlen = 0
-        states = []  # [(category, [(prefix, value), ])]
-        fmt = lambda v: "" if v in (None, {}) else \
-                        next((x[1:-1] if isinstance(v, util.text_types)
-                              and re.match(r"[\x20-\x7e]+$", x) else x for x in [json.dumps(v)]))
+        states, maxlen = [], 0, # [(category, [(prefix, value), ])]
         for p in self._plugins:  # Assemble YAML by hand for more readable indentation
-            pairs = []
-            props, state = p["instance"].props(), copy.copy(p["instance"].state())
-            for prop in props if isinstance(props, (list, tuple)) else [props]:
-                if "itemlist" == prop["type"]:
-                    while state and not state[-1]: state.pop()  # Strip empty trailing values
-                    for v in state:
-                        itempairs = []
-                        if not v or not isinstance(v, dict):
-                            itempairs += [("-%s" % ("" if v in (None, {}) else " "), fmt(v))]
-                        else:
-                            for itemprop in prop["item"]:
-                                if "name" in itemprop and itemprop["name"] in v:
-                                    maxlen = max(maxlen, len(itemprop["name"]))
-                                    lead = " " if itempairs else "-"
-                                    itempairs += [("%s %s:" % (lead, itemprop["name"]),
-                                                   fmt(v[itemprop["name"]]))]
-                        pairs.extend(itempairs)
-                elif "label" != prop["type"]:
-                    maxlen = max(maxlen, len(prop["name"]))
-                    pairs += [("%s%s:" % (INDENT, prop["name"]), fmt(state[prop["name"]]))]
+            pairs, prefixlen = self.serialize_plugin_yaml(hero, p["instance"], INDENT)
             states.append((p["name"], pairs))
-
+            maxlen = max(maxlen, prefixlen)
         maxlen += len(INDENT) + 3
-        formatted = LF + "".join(
-            "%s%s:%s%s%s%s" % (
-                INDENT, category, LF if pairs else "", INDENT if pairs else "",
-                (LF + INDENT).join("%s%s" % (a.ljust(maxlen) if b and a.strip() != "-" else a, b)
-                                   for a, b in pairs), LF
-            ) for category, pairs in states
-        )
-        name = yaml.safe_dump([self._hero.name], default_flow_style=True).strip()[1:-1]
-        return name + ":" + formatted
+        formatteds = ["%s%s:%s%s%s%s" % (
+            INDENT, category, LF if pairs else "", INDENT if pairs else "",
+            (LF + INDENT).join("%s%s" % (a.ljust(maxlen) if b and a.strip() != "-" else a, b)
+                               for a, b in pairs), LF
+        ) for category, pairs in states]
+        name = yaml.safe_dump([hero.name], default_flow_style=True).strip()[1:-1]
+        hero.yaml = "%s:%s%s" % (name, LF, "".join(formatteds))
+        setattr(hero, "yamls2" if changes else "yamls1", formatteds)
+
+
+    def serialize_plugin_yaml(self, hero, plugin, indent="  "):
+        """
+        Returns hero data from plugin as YAML components.
+
+        @param   plugin  plugin instance
+        @param   indent  line leading indent
+        @return          [(formatted prefix, formatted value)], raw prefix maxlen
+        """
+        pairs, maxlen = [], 0
+        fmt = lambda v: "" if v in (None, {}) else \
+                        next((x[1:-1] if isinstance(v, util.text_types)
+                              and re.match(r"[\x20-\x7e]+$", x) else x for x in [json.dumps(v)]))
+        props = plugin.props()
+        state = copy.copy(plugin.state()) if plugin.item() == hero else \
+                getattr(hero, plugin.name) if hasattr(hero, plugin.name) else plugin.parse([hero])[0]
+        for prop in props if isinstance(props, (list, tuple)) else [props]:
+            if "itemlist" == prop["type"]:
+                while state and not state[-1]: state.pop()  # Strip empty trailing values
+                for v in state:
+                    itempairs = []
+                    if not v or not isinstance(v, dict):
+                        itempairs += [("-%s" % ("" if v in (None, {}) else " "), fmt(v))]
+                    else:
+                        for itemprop in prop["item"]:
+                            if "name" in itemprop and itemprop["name"] in v:
+                                maxlen = max(maxlen, len(itemprop["name"]))
+                                lead = " " if itempairs else "-"
+                                itempairs += [("%s %s:" % (lead, itemprop["name"]),
+                                               fmt(v[itemprop["name"]]))]
+                    pairs.extend(itempairs)
+            elif "label" != prop["type"]:
+                maxlen = max(maxlen, len(prop["name"]))
+                pairs += [("%s%s:" % (indent, prop["name"]), fmt(state[prop["name"]]))]
+        return pairs, maxlen
 
 
     def get_data(self):
         """Returns copy of current hero object."""
-        if not self._hero: return None
-        hero = Hero(None, None, None, None)
-        for k, v in vars(self._hero).items():
-            v2 = v if isinstance(v, metadata.Savefile) else copy.deepcopy(v)
-            setattr(hero, k, v2)
-        return hero
+        return self._hero.copy() if self._hero else None
 
 
     def set_data(self, hero):
         """Sets current hero object."""
-        self._hero = Hero(hero.name, hero.bytes, hero.span, hero.savefile)
-        for k, v in vars(hero).items():
-            v2 = v if isinstance(v, metadata.Savefile) else copy.deepcopy(v)
-            setattr(self._hero, k, v2)
-        self._ctrls["hero"].Value = hero.name
+        combo, tabs = self._ctrls["hero"], self._ctrls["tabs"]
+        index = next(i for i, h in enumerate(self._heroes) if h == hero)
+        if index in self._pages.values():
+            page = next(p for p, i in self._pages.items() if i == index)
+            idx  = next(i for i in range(tabs.GetPageCount()) if page is tabs.GetPage(i))
+            tabs.SetSelection(idx)
+        else:
+            page = wx.Window(tabs)
+            self._pages[page] = index
+            tabs.AddPage(page, hero.name, select=True)
+            self._indexpanel.Hide()
+            self._heropanel.Show()
+        if not self._hero:
+            self._hero = next(h for h in self._heroes if h == hero)
+        self._hero.update(hero)
+        combo.SetSelection(index)
+
+
+    def get_changes(self):
+        """Returns changes to current heroes, as HTML diff content."""
+        changes, tpl = [], step.Template(templates.HERO_DIFF_HTML, escape=True)
+        for hero in self._heroes:
+            if hero.yamls1 and hero.yamls2 and hero.yamls1 != hero.yamls2:
+                changes.append(tpl.expand(name=hero.name, changes=[
+                    (v1, v2) for v1, v2 in zip(hero.yamls1, hero.yamls2) if v1 != v2
+                ]))
+        return "\n".join(changes)
 
 
     def patch(self):
         """Serializes current plugin state to hero bytes, patches savefile binary."""
         for p in self._plugins:
             if callable(getattr(p.get("instance"), "serialize", None)):
                 self._hero.bytes = p["instance"].serialize()
         self.savefile.patch(self._hero.bytes, self._hero.span)
+        self.serialize_yaml(self._hero, changes=True)
+        changed = self._hero.yamls2 and self._hero.yamls1 != self._hero.yamls2
+        title = "%s%s" % (self._hero.name, "*" if changed else "")
+        index = next(i for i, h in enumerate(self._heroes) if h == self._hero)
+        page = next(p for p, i in self._pages.items() if i == index)
+        self._ctrls["tabs"].SetPageText(self._ctrls["tabs"].GetPageIndex(page), title)
         wx.PostEvent(self._panel, gui.SavefilePageEvent(self._panel.Id))
 
 
     def render_plugin(self, name, reload=False):
         """
         Renders or re-renders panel for the specified plugin.
 
         @param   reload  whether plugins should re-parse state from hero bytes
         """
         p = next((x for x in self._plugins if x["name"] == name), None)
         if not p:
             logger.warning("Call to render unknown plugin %s.", name)
             return
 
-        obj = obj0 = p.get("instance")
-        if not obj:
-            try:
-                obj = p["module"].factory(self, self._hero, p["panel"])
-            except Exception:
-                logger.exception("Error instantiating %s plugin.", p["name"])
-                return
-            p["instance"] = obj
-        elif reload: obj.load(self._hero, p["panel"])
-        if reload or not obj0:
+        obj, item0 = p["instance"], p["instance"].item()
+        if reload or item0 is None:
+            obj.load(self._hero, p["panel"])
             logger.info("Loaded hero %s %s %s.", self._hero.name, p["name"], obj.state())
-
-        if   callable(getattr(obj, "render", None)): obj.render()
-        elif callable(getattr(obj, "props",  None)): gui.build(obj, p["panel"])
-        if not obj0 or reload: wx_accel.accelerate(p["panel"])
+        p["panel"].Freeze()
+        try:
+            if   callable(getattr(obj, "render", None)): obj.render()
+            elif callable(getattr(obj, "props",  None)): gui.build(obj, p["panel"])
+            if reload or item0 is None: wx_accel.accelerate(p["panel"])
+        finally:
+            p["panel"].Thaw()
```

## h3sed/plugins/hero/army.py

```diff
@@ -3,20 +3,22 @@
 Army subplugin for hero-plugin, shows hero army creatures and counts.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   21.03.2020
-@modified  16.01.2022
+@modified  26.02.2023
 ------------------------------------------------------------------------------
 """
 import copy
 import logging
 
+import wx
+
 from h3sed import gui
 from h3sed import metadata
 from h3sed import plugins
 from h3sed.lib import util
 from h3sed.plugins.hero import POS
 
 
@@ -50,96 +52,96 @@
 
 
 def props():
     """Returns props for army-tab, as {label, index}."""
     return PROPS
 
 
-def factory(parent, hero, panel):
+def factory(savefile, parent, panel):
     """Returns a new army-plugin instance."""
-    return ArmyPlugin(parent, hero, panel)
+    return ArmyPlugin(savefile, parent, panel)
 
 
 
 class ArmyPlugin(object):
     """Encapsulates army-plugin state and behaviour."""
 
 
-    def __init__(self, parent, hero, panel):
-        self.name    = PROPS["name"]
-        self.parent  = parent
-        self._hero   = hero
-        self._panel  = panel # Plugin contents panel
-        self._state  = []    # [{"name": "Roc", "count": 6}, {}, ]
-        self._state0 = []    # Original state [{"name": "Roc", "count": 6}, {}, ]
-        self._ctrls  = []    # [{"name": wx.ComboBox, "count": wx.SpinCtrl}, ]
-        if hero:
-            self.parse(hero.bytes)
-            hero.army = self._state
+    def __init__(self, savefile, parent, panel):
+        self.name      = PROPS["name"]
+        self.parent    = parent
+        self._savefile = savefile
+        self._hero     = None
+        self._panel    = panel  # Plugin contents panel
+        self._state    = []     # [{"name": "Roc", "count": 6}, {}, ]
+        self._state0   = []     # Original state [{"name": "Roc", "count": 6}, {}, ]
+        self._ctrls    = []     # [{"name": wx.ComboBox, "count": wx.SpinCtrl}, ]
 
 
     def props(self):
         """Returns props for army-tab, as [{type: "itemlist", ..}]."""
         result = []
-        ver = self._hero.savefile.version
-        cc = sorted(metadata.Store.get("creatures", version=ver))
+        cc = sorted(metadata.Store.get("creatures", self._savefile.version))
         for prop in UIPROPS:
             myprop = dict(prop, item=[])
             for item in prop["item"]:
                 myitem = dict(item, choices=cc) if "choices" in item else item
                 myprop["item"].append(myitem)
             result.append(myprop)
         return result
 
 
     def state(self):
         """Returns data state for army-plugin, as [{"name": "Roc", "count": 6}, {}, ]."""
         return self._state
 
 
+    def item(self):
+        """Returns current hero."""
+        return self._hero
+
+
     def load(self, hero, panel=None):
         """Loads hero to plugin."""
         self._hero = hero
-        self._state[:] = []
-        if panel: self._panel = panel
-        if hero:
-            self.parse(hero.bytes)
-            hero.army = self._state
+        self._state[:] = self.parse([hero])[0]
+        self._state0 = copy.deepcopy(self._state)
+        hero.army = self._state
+        if panel:
+            panel.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.on_colour_change)
+            self._panel = panel
 
 
     def load_state(self, state):
         """Loads plugin state from given data, ignoring unknown values. Returns whether state changed."""
         MYPROPS = self.props()
         state0 = type(self._state)(self._state)
-        state = state + [{}] * (MYPROPS[0]["max"] - len(state))
-        ver = self._hero.savefile.version
-        cmap = {x.lower(): x for x in metadata.Store.get("creatures", version=ver)}
+        cmap = {x.lower(): x for x in metadata.Store.get("creatures", self._savefile.version)}
         countitem = next(x for x in MYPROPS[0]["item"] if "count" == x.get("name"))
         MIN, MAX = countitem["min"], countitem["max"]
-        for i, v in enumerate(state):
+        state = state + [{}] * (MYPROPS[0]["max"] - len(state))
+        for i, v in enumerate(state[:MYPROPS[0]["max"]]):
+            self._state[i] = {}
             if not isinstance(v, (dict, type(None))):
                 logger.warning("Invalid data type in army #%s: %r", i + 1, v)
                 continue  # for
             name, count = v and v.get("name"), v and v.get("count")
             if name and hasattr(name, "lower") and name.lower() in cmap \
             and isinstance(count, int) and MIN <= count <= MAX:
                 self._state[i] = {"name": cmap[name.lower()], "count": count}
-            elif v in ({}, None):
-                self._state[i] = {}
-            else:
+            elif v:
                 logger.warning("Invalid army #%s: %r", i + 1, v)
         return state0 != self._state
 
 
     def render(self):
         """Populates controls from state, using existing if already built."""
         MYPROPS = self.props()
         if self._ctrls and all(all(x.values()) for x in self._ctrls):
-            ver = self._hero.savefile.version
-            cc = [""] + sorted(metadata.Store.get("creatures", version=ver))
+            cc = [""] + sorted(metadata.Store.get("creatures", self._savefile.version))
             for i, row in enumerate(self._state):
                 creature = None
                 for prop in MYPROPS[0]["item"]:
                     if "name" not in prop: continue # for prop
                     name, choices = prop["name"], cc
                     ctrl, value = self._ctrls[i][name], self._state[i].get(name)
                     if "choices" in prop:
@@ -171,43 +173,56 @@
         Returns True.
         """
         row[prop["name"]] = value
         if "name" == prop["name"]:
             if value and not row.get("count"):
                 row["count"] = ctrl.GetNextSibling().Value = 1
             ctrl.GetNextSibling().Show(bool(value))
+            ctrl.GetNextSibling().GetNextSibling().Show(not value)
         return True
 
 
-    def parse(self, bytes):
-        """Builds army state from hero bytearray."""
-        result = []
+    def on_colour_change(self, event):
+        """Handler for system colour change, refreshes panel to clear any display issues."""
+        event.Skip()
+        def after():
+            if not self._panel: return
+            for c in self._panel.Children:
+                if isinstance(c, wx.SpinCtrl) and not c.Shown: c.Show(), c.Hide()
+            wx.CallAfter(lambda: self._panel and self._panel.Refresh())
+        wx.CallLater(100, after)  # Hidden SpinCtrl arrows can become visible on colour change
 
-        NAMES = {x[y]: y for x in [metadata.Store.get("ids")]
-                 for y in metadata.Store.get("creatures")}
+
+    def parse(self, heroes):
+        """Returns army states parsed from hero bytearrays, as [[{name, count} or {}, ], ]."""
+        result = []
+        NAMES = {x[y]: y for x in [metadata.Store.get("ids", self._savefile.version)]
+                 for y in metadata.Store.get("creatures", self._savefile.version)}
         MYPOS = plugins.adapt(self, "pos", POS)
 
-        for prop in self.props():
-            for i in range(prop["max"]):
-                unit  = util.bytoi(bytes[MYPOS["army_types"]  + i * 4:MYPOS["army_types"]  + i * 4 + 4])
-                count = util.bytoi(bytes[MYPOS["army_counts"] + i * 4:MYPOS["army_counts"] + i * 4 + 4])
-                name = NAMES.get(unit)
-                if not unit or not count or not name: result.append({})
-                else: result.append({"name": name, "count": count})
-        self._state[:] = result
-        self._state0 = copy.deepcopy(result)
+        for hero in heroes:
+            values = []
+            for prop in self.props():
+                for i in range(prop["max"]):
+                    unit, count = (util.bytoi(hero.bytes[MYPOS[k]  + i * 4:MYPOS[k]  + i * 4 + 4])
+                                   for k in ("army_types", "army_counts"))
+                    name = NAMES.get(unit)
+                    if not unit or not count or not name: values.append({})
+                    else: values.append({"name": name, "count": count})
+            result.append(values)
+        return result
 
 
     def serialize(self):
         """Returns new hero bytearray, with edited army section."""
         result = self._hero.bytes[:]
         bytes0 = self._hero.get_bytes(original=True)
 
-        IDS = {y: x[y] for x in [metadata.Store.get("ids")]
-               for y in metadata.Store.get("creatures")}
+        IDS = {y: x[y] for x in [metadata.Store.get("ids", self._savefile.version)]
+               for y in metadata.Store.get("creatures", self._savefile.version)}
         MYPOS = plugins.adapt(self, "pos", POS)
 
         for prop in self.props():
             for i in range(prop["max"]):
                 name, count = (self._state[i].get(x) for x in ("name", "count"))
                 if (not name or not count) and not self._state0[i].get("name"):
                     # Retain original bytes unchanged, as game uses both 0x00 and 0xFF
```

## h3sed/plugins/hero/artifacts.py

```diff
@@ -3,15 +3,15 @@
 Artifacts subplugin for hero-plugin, shows artifact selection slots like helm etc.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   16.03.2020
-@modified  16.01.2022
+@modified  26.02.2023
 ------------------------------------------------------------------------------
 """
 from collections import defaultdict
 import logging
 
 import wx
 
@@ -22,179 +22,203 @@
 from h3sed.lib import util
 from h3sed.plugins.hero import POS
 
 
 logger = logging.getLogger(__package__)
 
 
+def format_stats(plugin, prop, state, artifact_stats=None):
+    """Return item primaty stats modifer text like "+1 Attack, +1 Defense", or "" if no effect."""
+    value = state.get(prop.get("name"))
+    if not value: return ""
+    STATS = artifact_stats or metadata.Store.get("artifact_stats", plugin._savefile.version)
+    if value not in STATS: return ""
+    return ", ".join("%s%s %s" % ("" if v < 0 else "+", v, k)
+                     for k, v in zip(metadata.PrimaryAttributes.values(), STATS[value]) if v)
+
+
 PROPS = {"name": "artifacts", "label": "Artifacts", "index": 2}
 UIPROPS = [{
     "name":     "helm",
     "label":    "Helm slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None, # Populated later
+    "info":     format_stats,
 }, {
     "name":     "neck",
     "label":    "Neck slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "armor",
     "label":    "Armor slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "weapon",
     "label":    "Weapon slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "shield",
     "label":    "Shield slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "lefthand",
     "label":    "Left hand slot",
     "type":     "combo",
     "slot":     "hand",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "righthand",
     "label":    "Right hand slot",
     "type":     "combo",
     "slot":     "hand",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "cloak",
     "label":    "Cloak slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "feet",
     "label":    "Feet slot",
     "type":     "combo",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "side1",
     "label":    "Side slot 1",
     "type":     "combo",
     "slot":     "side",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "side2",
     "label":    "Side slot 2",
     "type":     "combo",
     "slot":     "side",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "side3",
     "label":    "Side slot 3",
     "type":     "combo",
     "slot":     "side",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "side4",
     "label":    "Side slot 4",
     "type":     "combo",
     "slot":     "side",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }, {
     "name":     "side5",
     "label":    "Side slot 5",
     "type":     "combo",
     "slot":     "side",
     "nullable": True,
     "choices":  None,
+    "info":     format_stats,
 }]
 
 
 
 def props():
     """Returns props for artifacts-tab, as {label, index}."""
     return PROPS
 
 
-def factory(parent, hero, panel):
+def factory(savefile, parent, panel):
     """Returns a new artifacts-plugin instance."""
-    return ArtifactsPlugin(parent, hero, panel)
+    return ArtifactsPlugin(savefile, parent, panel)
 
 
 
 class ArtifactsPlugin(object):
     """Encapsulates artifacts-plugin state and behaviour."""
 
 
-    def __init__(self, parent, hero, panel):
-        self.name    = PROPS["name"]
-        self.parent  = parent
-        self._hero   = hero
-        self._panel  = panel # Plugin contents panel
-        self._state  = {}    # {helm: "Skull Helmet", ..}
-        self._ctrls  = {}    # {"head": wx.ComboBox, }
-        if hero:
-            self.parse(hero.bytes)
-            hero.artifacts = self._state
+    def __init__(self, savefile, parent, panel):
+        self.name      = PROPS["name"]
+        self.parent    = parent
+        self._savefile = savefile
+        self._hero     = None
+        self._panel    = panel  # Plugin contents panel
+        self._state    = {}     # {"helm": "Skull Helmet", ..}
+        self._ctrls    = {}     # {"helm": wx.ComboBox, "helm-info": wx.StaticText, }
 
 
     def props(self):
         """Returns props for artifacts-tab, as [{type: "combo", ..}]."""
         result = []
-        ver = self._hero.savefile.version
+        version = self._savefile.version
         for prop in UIPROPS:
             slot = prop.get("slot", prop["name"])
-            cc = [""] + sorted(metadata.Store.get("artifacts", version=ver, category=slot))
+            cc = [""] + sorted(metadata.Store.get("artifacts", version, category=slot))
             result.append(dict(prop, choices=cc))
         return result
 
 
     def state(self):
         """Returns data state for artifacts-plugin, as {helm, ..}."""
         return self._state
 
 
+    def item(self):
+        """Returns current hero."""
+        return self._hero
+
+
     def load(self, hero, panel):
         """Loads hero to plugin."""
         self._hero = hero
         self._state.clear()
+        self._state.update(self.parse([hero])[0])
+        hero.artifacts = self._state
+        hero.ensure_basestats()
         if panel: self._panel = panel
-        if hero:
-            self.parse(hero.bytes)
-            hero.artifacts = self._state
 
 
     def load_state(self, state):
         """Loads plugin state from given data, ignoring unknown values."""
         state0 = type(self._state)(self._state)
-        ver = self._hero.savefile.version
-        stats_diff = [0, 0, 0, 0]
+        version = self._savefile.version
 
         for prop in self.props():  # First pass: don items
             name, slot = prop["name"], prop.get("slot", prop["name"])
             if name not in state:
                 continue  # for
             v = state[name]
-            cmap = {x.lower(): x for x in metadata.Store.get("artifacts", version=ver, category=slot)}
+            cmap = {x.lower(): x for x in metadata.Store.get("artifacts", version, category=slot)}
 
             if not v or hasattr(v, "lower") and v.lower() in cmap:
-                v0 = self._state[name]
-                stats_diff = [a + b for a, b in zip(stats_diff, self._get_stats_diff(v0, v))]
                 self._state[name] = v
             else:
                 logger.warning("Invalid artifact for %r: %r", name, v)
 
         for prop in self.props():  # Second pass: validate slots and drop invalid states
             name, slot = prop["name"], prop.get("slot", prop["name"])
             v = self._state[name]
@@ -202,48 +226,51 @@
 
             slots_free, slots_owner = self._slots(prop, v)
             slots_full = [k for k, x in slots_free.items() if x < 0]
             if slots_full:
                 logger.warning("Cannot don %s, required slot taken:\n\n%s.",
                                v, "\n".join("- %s (by %s)" % (x, ", ".join(sorted(slots_owner[x])))
                                             for x in sorted(slots_full)))
-                stats_diff = [a + b for a, b in zip(stats_diff, self._get_stats_diff(v, None))]
                 self._state[name] = None
 
-        self._apply_stats_diff(stats_diff)
-        return state0 != self._state
+        result = (state0 != self._state)
+        self._hero.artifacts = self._state
+        if result: self._apply_artifact_stats()
+        return result
 
 
     def render(self):
         """Populates controls from state, using existing if already built."""
-        ver = self._hero.savefile.version
+        version = self._savefile.version
         if self._ctrls and all(self._ctrls.values()):
+            STATS = metadata.Store.get("artifact_stats", version)
             for prop in self.props():
                 name, slot = prop["name"], prop.get("slot", prop["name"])
-                cc = [""] + sorted(metadata.Store.get("artifacts", version=ver, category=slot))
+                cc = [""] + sorted(metadata.Store.get("artifacts", version, category=slot))
 
                 ctrl, value, choices = self._ctrls[name], self._state.get(name), cc
                 if value and value not in choices: choices = [value] + cc
                 if choices != ctrl.GetItems(): ctrl.SetItems(choices)
                 ctrl.Value = value or ""
+                self._ctrls["%s-info" % name].Label = format_stats(self, prop, self._state, STATS)
         else:
             self._ctrls = gui.build(self, self._panel)
         self.update_slots()
 
 
     def update_slots(self):
         """Updates slots availability."""
-        ver = self._hero.savefile.version
+        version = self._savefile.version
         slots_free, slots_owner = self._slots()
-        SLOTS = metadata.Store.get("artifact_slots")
+        SLOTS = metadata.Store.get("artifact_slots", version)
         self._panel.Freeze()
         try:
             for prop in self.props():
                 name, slot = prop["name"], prop.get("slot", prop["name"])
-                cc = [""] + sorted(metadata.Store.get("artifacts", version=ver, category=slot))
+                cc = [""] + sorted(metadata.Store.get("artifacts", version, category=slot))
 
                 ctrl, value = self._ctrls[name], self._state.get(name)
 
                 if not ctrl.Enabled:
                     if value and value not in cc:
                         cc = [value] + cc
                     ctrl.SetItems(cc)
@@ -281,46 +308,44 @@
                                for x in sorted(slots_full))),
                 conf.Title, wx.OK | wx.ICON_WARNING
             )
             ctrl.Value = v1 or ""
             return False
 
         self._state[prop["name"]] = v2
-        if self._apply_stats_diff(self._get_stats_diff(v1, v2)):
+        self._hero.artifacts = self._state
+        if self._apply_artifact_stats():
             evt = gui.PluginEvent(self._panel.Id, action="render", name="stats")
             wx.PostEvent(self._panel, evt)
         self.update_slots()
+        self._ctrls["%s-info" % prop["name"]].Label = format_stats(prop, self._state)
         return True
 
 
-    def _get_stats_diff(self, item1, item2):
-        """Returns change in hero stats from swapping item1 for item2, as [int, int, int, int]."""
-        stats_diff = [0, 0, 0, 0]
-        STATS = metadata.Store.get("artifact_stats")
-        if item1 in STATS:
-            stats_diff = [a - b for a, b in zip(stats_diff, STATS[item1])]
-        if item2 in STATS:
-            stats_diff = [a + b for a, b in zip(stats_diff, STATS[item2])]
-        return stats_diff
-
-
-    def _apply_stats_diff(self, stats_diff):
-        """Apply change in hero main stats, returns whether anything was changed."""
-        apply = any(stats_diff) and hasattr(self._hero, "stats")
-        if apply:
-            # Artifact bonuses like +2 Attack are kept in primary stats
-            for n, v in zip(["attack", "defense", "power", "knowledge"], stats_diff):
-                self._hero.stats[n] += v
-                self._hero.stats[n] = min(max(0, self._hero.stats[n]), 127)
-        return apply
+    def _apply_artifact_stats(self):
+        """
+        Applies current artifact stats to hero primary stats, returns whether anything changed.
+        """
+        result = False
+        if not all(getattr(self._hero, k, None) for k in ("stats", "basestats")): return result
+
+        STATS = metadata.Store.get("artifact_stats", self._savefile.version)
+        diff = [0] * len(metadata.PrimaryAttributes)
+        for prop in self.props():
+            item = self._state[prop["name"]]
+            if item in STATS: diff = [a + b for a, b in zip(diff, STATS[item])]
+        for k, v in zip(metadata.PrimaryAttributes, diff):
+            v1, v2 = self._hero.stats[k], min(max(0, self._hero.basestats[k] + v), 127)
+            if v1 != v2: result, self._hero.stats[k] = True, v2
+        return result
 
 
     def _slots(self, prop=None, value=None):
         """Returns free and taken slots as {"side": 4, }, {"helm": "Skull Helmet", }."""
-        MYPROPS, SLOTS = self.props(), metadata.Store.get("artifact_slots")
+        MYPROPS, SLOTS = self.props(), metadata.Store.get("artifact_slots", self._savefile.version)
 
         # Check whether combination artifacts leave sufficient slots free
         slots_free, slots_owner = defaultdict(int), defaultdict(list)
         for myprop in MYPROPS:
             slots_free[myprop.get("slot", myprop["name"])] += 1
         for prop1 in MYPROPS:
             if prop and prop1["name"] == prop["name"]: continue # for prop
@@ -331,40 +356,45 @@
                 if v not in slots_owner[slot]: slots_owner[slot] += [v]
         if prop: slots_free[prop.get("slot", prop["name"])] -= 1
         for slot in SLOTS.get(value, ())[1:]: # First element is primary slot
             slots_free[slot] -= 1
         return slots_free, slots_owner
 
 
-    def parse(self, bytes):
-        """Builds artifacts list from hero bytearray, as {helm, ..}."""
-        result = {}
-        IDS   = metadata.Store.get("ids")
+    def parse(self, heroes):
+        """Returns artifacts states parsed from hero bytearrays, as [{helm, ..}, ]."""
+        result = []
+        IDS   = metadata.Store.get("ids", self._savefile.version)
         NAMES = {x[y]: y for x in [IDS]
-                 for y in metadata.Store.get("artifacts", category="inventory")}
+                 for y in metadata.Store.get("artifacts", self._savefile.version,
+                                             category="inventory")}
         MYPOS = plugins.adapt(self, "pos", POS)
 
-        def parse_item(pos):
-            b, v = bytes[pos:pos + 4], util.bytoi(bytes[pos:pos + 4])
+        def parse_item(hero, pos):
+            b, v = hero.bytes[pos:pos + 4], util.bytoi(hero.bytes[pos:pos + 4])
             if all(x == ord(metadata.Blank) for x in b): return None # Blank
-            return util.bytoi(bytes[pos:pos + 8]) if v == IDS["Spell Scroll"] else v
+            return util.bytoi(hero.bytes[pos:pos + 8]) if v == IDS["Spell Scroll"] else v
 
-        for prop in self.props():
-            result[prop["name"]] = NAMES.get(parse_item(MYPOS[prop["name"]]))
-        self._state.clear(); self._state.update(result)
+        for hero in heroes:
+            values = {}
+            for prop in self.props():
+                values[prop["name"]] = NAMES.get(parse_item(hero, MYPOS[prop["name"]]))
+            result.append(values)
+        return result
 
 
     def serialize(self):
         """Returns new hero bytearray, with edited artifacts section."""
         result = self._hero.bytes[:]
+        version = self._savefile.version
 
-        IDS = {y: x[y] for x in [metadata.Store.get("ids")]
-               for y in metadata.Store.get("artifacts", category="inventory")}
+        IDS = {y: x[y] for x in [metadata.Store.get("ids", version)]
+               for y in metadata.Store.get("artifacts", version, category="inventory")}
         MYPOS = plugins.adapt(self, "pos", POS)
-        SLOTS = metadata.Store.get("artifact_slots")
+        SLOTS = metadata.Store.get("artifact_slots", version)
 
         pos_reserved, len_reserved = min(MYPOS["reserved"].values()), len(MYPOS["reserved"])
         result[pos_reserved:pos_reserved + len_reserved] = [0] * len_reserved
 
         for prop in self.props():
             name = self._state[prop["name"]]
             v, pos = IDS.get(name), MYPOS[prop["name"]]
```

## h3sed/plugins/hero/inventory.py

```diff
@@ -3,15 +3,15 @@
 Inventory subplugin for hero-plugin, shows inventory artifacts list.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   16.03.2020
-@modified  16.01.2022
+@modified  26.02.2023
 ------------------------------------------------------------------------------
 """
 import copy
 import logging
 
 from h3sed import gui
 from h3sed import metadata
@@ -43,72 +43,74 @@
 
 
 def props():
     """Returns props for inventory-tab, as {label, index}."""
     return PROPS
 
 
-def factory(parent, hero, panel):
+def factory(savefile, parent, panel):
     """Returns a new inventory-plugin instance."""
-    return InventoryPlugin(parent, hero, panel)
+    return InventoryPlugin(savefile, parent, panel)
 
 
 
 class InventoryPlugin(object):
     """Encapsulates inventory-plugin state and behaviour."""
 
 
-    def __init__(self, parent, hero, panel):
-        self.name    = PROPS["name"]
-        self.parent  = parent
-        self._hero   = hero
-        self._panel  = panel # Plugin contents panel
-        self._state  = []    # ["Skull Helmet", None, ..]
-        self._state0 = []    # Original state ["Skull Helmet", None, ..]
-        self._ctrls  = []    # [wx.ComboBox, ]
-        if hero:
-            self.parse(hero.bytes)
-            hero.inventory = self._state
+    def __init__(self, savefile, parent, panel):
+        self.name      = PROPS["name"]
+        self.parent    = parent
+        self._savefile = savefile
+        self._hero     = None
+        self._panel    = panel  # Plugin contents panel
+        self._state    = []     # ["Skull Helmet", None, ..]
+        self._state0   = []     # Original state ["Skull Helmet", None, ..]
+        self._ctrls    = []     # [wx.ComboBox, ]
 
 
     def props(self):
         """Returns props for inventory-tab, as [{type: "itemlist", ..}]."""
         result = []
-        ver = self._hero.savefile.version
-        cc = sorted(metadata.Store.get("artifacts", version=ver, category="inventory"))
+        cc = sorted(metadata.Store.get("artifacts", self._savefile.version, category="inventory"))
         for prop in UIPROPS:
             myprop = dict(prop, item=[])
             for item in prop["item"]:
                 myitem = dict(item, choices=cc) if "choices" in item else item
                 myprop["item"].append(myitem)
             result.append(myprop)
         return result
 
 
     def state(self):
         """Returns data state for inventory-plugin, as ["Skull Helmet", None, ..]."""
         return self._state
 
 
+    def item(self):
+        """Returns current hero."""
+        return self._hero
+
+
     def load(self, hero, panel=None):
         """Loads hero to plugin."""
         self._hero = hero
-        self._state[:] = []
+        self._state[:] = self.parse([hero])[0]
+        self._state0 = copy.deepcopy(self._state)
+        hero.inventory = self._state
         if panel: self._panel = panel
-        if hero:
-            self.parse(hero.bytes)
-            hero.inventory = self._state
 
 
     def load_state(self, state):
         """Loads plugin state from given data, ignoring unknown values. Returns whether state changed."""
         state0 = type(self._state)(self._state)
         state = state + [None] * (self.props()[0]["max"] - len(state))
-        ver = self._hero.savefile.version
-        cmap = {x.lower(): x for x in metadata.Store.get("artifacts", version=ver, category="inventory")}
+        version = self._savefile.version
+        cmap = {x.lower(): x
+                for x in metadata.Store.get("artifacts", version, category="inventory")}
         for i, v in enumerate(state):
             if v and hasattr(v, "lower") and v.lower() in cmap:
                 self._state[i] = cmap[v.lower()]
             elif v in ("", None):
                 self._state[i] = None
             else:
                 logger.warning("Invalid inventory item #%s: %r", i + 1, v)
@@ -120,43 +122,44 @@
         if self._ctrls and all(self._ctrls):
             for i, value in enumerate(self._state):
                 self._ctrls[i].Value = value or ""
         else:
             self._ctrls = gui.build(self, self._panel)[0]
 
 
-    def parse(self, bytes):
-        """Builds inventory state from hero bytearray."""
+    def parse(self, heroes):
+        """Returns inventory states parsed from hero bytearrays, as [[item or None, ..], ]."""
         result = []
-
-        IDS   = metadata.Store.get("ids")
-        NAMES = {x[y]: y for x in [IDS]
-                 for y in metadata.Store.get("artifacts", category="inventory")}
+        IDS   = metadata.Store.get("ids", self._savefile.version)
+        NAMES = {x[y]: y for x in [IDS] for y in
+                 metadata.Store.get("artifacts", self._savefile.version, category="inventory")}
         MYPOS = plugins.adapt(self, "pos", POS)
 
-        def parse_item(pos):
-            b, v = bytes[pos:pos + 4], util.bytoi(bytes[pos:pos + 4])
+        def parse_item(hero, pos):
+            b, v = hero.bytes[pos:pos + 4], util.bytoi(hero.bytes[pos:pos + 4])
             if all(x == metadata.Blank for x in b): return None # Blank
-            return util.bytoi(bytes[pos:pos + 8]) if v == IDS["Spell Scroll"] else v
+            return util.bytoi(hero.bytes[pos:pos + 8]) if v == IDS["Spell Scroll"] else v
 
-        for prop in self.props():
-            for i in range(prop["max"]):
-                v = parse_item(MYPOS["inventory"] + i*8)
-                result.append(NAMES.get(v))
-        self._state[:] = result
-        self._state0 = copy.deepcopy(result)
+        for hero in heroes:
+            values = []
+            for prop in self.props():
+                for i in range(prop["max"]):
+                    v = parse_item(hero, MYPOS["inventory"] + i*8)
+                    values.append(NAMES.get(v))
+            result.append(values)
+        return result
 
 
     def serialize(self):
         """Returns new hero bytearray, with edited inventory section."""
         result = self._hero.bytes[:]
         bytes0 = self._hero.get_bytes(original=True)
 
-        IDS = metadata.Store.get("ids")
-        SCROLL_ARTIFACTS = metadata.Store.get("artifacts", category="scroll")
+        IDS = metadata.Store.get("ids", self._savefile.version)
+        SCROLL_ARTIFACTS = metadata.Store.get("artifacts", self._savefile.version, category="scroll")
         MYPOS = plugins.adapt(self, "pos", POS)
         pos = MYPOS["inventory"]
 
         for prop in self.props():
             for i, name in enumerate(self._state) if "itemlist" == prop["type"] else ():
                 v = IDS.get(name)
                 if name in SCROLL_ARTIFACTS:
```

## h3sed/plugins/hero/skills.py

```diff
@@ -3,19 +3,23 @@
 Skills subplugin for hero-plugin, shows skills list.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   14.03.2020
-@modified  16.01.2022
+@modified  27.02.2023
 ------------------------------------------------------------------------------
 """
 import logging
 
+import wx
+
+from h3sed.lib import controls
+from h3sed import gui
 from h3sed import metadata
 from h3sed import plugins
 from h3sed.plugins.hero import POS
 
 
 logger = logging.getLogger(__package__)
 
@@ -34,55 +38,51 @@
         "name":     "name",
         "type":     "label",
     }, {
         "name":     "level",
         "type":     "combo",
         "choices":  None
     }],
-}, {
-    "type":     "label",
-    "label":    "More than 8 skills can be added.\n"
-                "Game will not show them on the hero screen,\n"
-                "but they will be in effect.",
 }]
+HINT = ("More than 8 skills can be added.\n"
+        "Game will not show them on the hero screen,\n"
+        "but they will be in effect.")
 
 
 
 def props():
     """Returns props for skills-tab, as {label, index}."""
     return PROPS
 
 
-def factory(parent, hero, panel):
+def factory(savefile, parent, panel):
     """Returns a new skills-plugin instance."""
-    return SkillsPlugin(parent, hero, panel)
+    return SkillsPlugin(savefile, parent, panel)
 
 
 
 class SkillsPlugin(object):
     """Encapsulates skills-plugin state and behaviour."""
 
 
-    def __init__(self, parent, hero, panel):
-        self.name    = PROPS["name"]
-        self.parent  = parent
-        self._hero   = hero
-        self._panel  = panel # Plugin contents panel
-        self._state  = []    # [{"name": "Estates", "level": "Basic"}, {..}]
-        if hero:
-            self.parse(hero.bytes)
-            hero.skills = self._state
+    def __init__(self, savefile, parent, panel):
+        self.name      = PROPS["name"]
+        self.parent    = parent
+        self._savefile = savefile
+        self._hero     = None
+        self._panel    = panel  # Plugin contents panel
+        self._state    = []     # [{"name": "Estates", "level": "Basic"}, {..}]
 
 
     def props(self):
         """Returns props for skills-tab, as {type: "itemlist", ..}."""
         result = []
-        ver = self._hero.savefile.version
-        ss = sorted(metadata.Store.get("skills", version=ver))
-        ll = metadata.Store.get("skill_levels", version=ver)
+        version = self._savefile.version
+        ss = sorted(metadata.Store.get("skills", version))
+        ll = metadata.Store.get("skill_levels", version)
         for prop in UIPROPS:
             myprop = dict(prop)
             if "itemlist" == prop["type"]:
                 myprop.update(item=[], choices=ss)
                 for item in prop["item"]:
                     myitem = dict(item, choices=ll) if "choices" in item else item
                     myprop["item"].append(myitem)
@@ -91,31 +91,34 @@
 
 
     def state(self):
         """Returns data state for skills-plugin, as [{name, level}]."""
         return self._state
 
 
+    def item(self):
+        """Returns current hero."""
+        return self._hero
+
+
     def load(self, hero, panel=None):
         """Loads hero to plugin."""
         self._hero = hero
-        self._state[:] = []
+        self._state[:] = self.parse([hero])[0]
+        hero.skills = self._state
         if panel: self._panel = panel
-        if hero:
-            self.parse(hero.bytes)
-            hero.skills = self._state
 
 
     def load_state(self, state):
         """Loads plugin state from given data, ignoring unknown values. Returns whether state changed."""
         state0 = type(self._state)(self._state)
         state = state[:self.props()[0]["max"]]
-        ver = self._hero.savefile.version
-        smap = {x.lower(): x for x in metadata.Store.get("skills", version=ver)}
-        lmap = {x.lower(): x for x in metadata.Store.get("skill_levels", version=ver)}
+        version = self._savefile.version
+        smap = {x.lower(): x for x in metadata.Store.get("skills", version)}
+        lmap = {x.lower(): x for x in metadata.Store.get("skill_levels", version)}
         self._state = type(self._state)()
         for i, v in enumerate(state):
             if not isinstance(v, dict):
                 logger.warning("Invalid data type in skill #%s: %r", i + 1, v)
                 continue  # for
             name, level = v.get("name"), v.get("level")
             if name and name.lower() in smap and level and level.lower() in lmap:
@@ -125,47 +128,59 @@
         return state0 != self._state
 
 
     def on_add(self, prop, value):
         """Adds skill at first level."""
         if any(value == x["name"] for x in self._state):
             return False
-        level = next(iter(metadata.Store.get("skill_levels")))
+        level = next(iter(metadata.Store.get("skill_levels", self._savefile.version)))
         self._state.append({"name": value, "level": level})
         return True
 
 
-    def parse(self, bytes):
-        """Builds skills state from hero bytearray."""
+    def render(self):
+        """Builds plugin controls into panel."""
+        gui.build(self, self._panel)
+        label = wx.StaticText(self._panel, label=HINT)
+        controls.ColourManager.Manage(label, "ForegroundColour", wx.SYS_COLOUR_GRAYTEXT)
+        self._panel.Sizer.Add(label, border=10, flag=wx.TOP, proportion=1)
+        self._panel.Layout()
+
+
+    def parse(self, heroes):
+        """Returns skills states parsed from hero bytearrays, as [{name, level, slot}]."""
         result = []
-        IDS    = {y: x[y] for x in [metadata.Store.get("ids")]
-                  for y in metadata.Store.get("skills")}
-        LEVELNAMES = {x[y]: y for x in [metadata.Store.get("ids")]
-                      for y in metadata.Store.get("skill_levels")}
+        version = self._savefile.version
+        IDS = {y: x[y] for x in [metadata.Store.get("ids", version)]
+               for y in metadata.Store.get("skills", version)}
+        LEVELNAMES = {x[y]: y for x in [metadata.Store.get("ids", version)]
+                      for y in metadata.Store.get("skill_levels", version)}
         MYPOS = plugins.adapt(self, "pos", POS)
 
-        count = bytes[MYPOS["skills_count"]]
-        ver = self._hero.savefile.version
-        for name in metadata.Store.get("skills", version=ver):
-            pos = IDS.get(name)
-            level, slot = bytes[MYPOS["skills_level"] + pos], bytes[MYPOS["skills_slot"] + pos]
-            if not level or not slot or slot > count:
-                continue # for i
-            result.append({"name": name, "level": LEVELNAMES[level], "slot": slot})
-        self._state[:] = sorted(result, key=lambda x: x.pop("slot"))
+        for hero in heroes:
+            values = []
+            count = hero.bytes[MYPOS["skills_count"]]
+            for name in metadata.Store.get("skills", version):
+                pos = IDS.get(name)
+                level, slot = (hero.bytes[MYPOS[k] + pos] for k in ("skills_level", "skills_slot"))
+                if not level or not slot or slot > count:
+                    continue # for i
+                values.append({"name": name, "level": LEVELNAMES[level], "slot": slot})
+            result.append(sorted(values, key=lambda x: x.pop("slot")))
+        return result
 
 
     def serialize(self):
         """Returns new hero bytearray, with edited skills sections."""
         result = self._hero.bytes[:]
-        ver = self._hero.savefile.version
-        IDS    = {y: x[y] for x in [metadata.Store.get("ids")]
-                  for y in metadata.Store.get("skills", version=ver)}
-        LEVELS = {y: x[y] for x in [metadata.Store.get("ids")]
-                  for y in metadata.Store.get("skill_levels")}
+        version = self._savefile.version
+        IDS    = {y: x[y] for x in [metadata.Store.get("ids", version)]
+                  for y in metadata.Store.get("skills", version)}
+        LEVELS = {y: x[y] for x in [metadata.Store.get("ids", version)]
+                  for y in metadata.Store.get("skill_levels", version)}
         MYPOS = plugins.adapt(self, "pos", POS)
 
         levels, count = bytearray(len(IDS)), 0
         slots         = bytearray(len(IDS))
         for slot, skill in enumerate(self._state, 1):
             name, level = skill["name"], skill["level"]
             pos = IDS.get(name)
```

## h3sed/plugins/hero/spells.py

```diff
@@ -3,15 +3,15 @@
 Spells subplugin for hero-plugin, shows hero learned spells list.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   20.03.2020
-@modified  18.01.2022
+@modified  26.02.2023
 ------------------------------------------------------------------------------
 """
 import logging
 
 from h3sed import gui
 from h3sed import metadata
 from h3sed import plugins
@@ -48,56 +48,55 @@
 
 
 
 class SpellsPlugin(object):
     """Encapsulates spells-plugin state and behaviour."""
 
 
-    def __init__(self, parent, hero, panel):
-        self.name    = PROPS["name"]
-        self.parent  = parent
-        self._hero   = hero
-        self._panel  = panel # Plugin contents panel
-        self._state  = []    # ["Haste", "Slow", ..]
-        if hero:
-            self.parse(hero.bytes)
-            hero.spells = self._state
+    def __init__(self, savefile, parent, panel):
+        self.name      = PROPS["name"]
+        self.parent    = parent
+        self._savefile = savefile
+        self._hero     = None
+        self._panel    = panel  # Plugin contents panel
+        self._state    = []     # ["Haste", "Slow", ..]
 
 
     def props(self):
         """Returns props for spells-tab, as [{type: "number", ..}]."""
         result = []
-        ver = self._hero.savefile.version
         for prop in UIPROPS:
-            cc = metadata.Store.get("spells", version=ver)
+            cc = metadata.Store.get("spells", self._savefile.version)
             result.append(dict(prop, choices=sorted(cc)))
         return result
 
 
     def state(self):
         """Returns data state for spells-plugin, as {mana, exp, ..}."""
         return self._state
 
 
+    def item(self):
+        """Returns current hero."""
+        return self._hero
+
+
     def load(self, hero, panel=None):
         """Loads hero to plugin."""
         self._hero = hero
-        self._state[:] = []
+        self._state[:] = self.parse([hero])[0]
+        hero.spells = self._state
         if panel: self._panel = panel
-        if hero:
-            self.parse(hero.bytes)
-            hero.spells = self._state
 
 
     def load_state(self, state):
         """Loads plugin state from given data, ignoring unknown values. Returns whether state changed."""
         state0 = type(self._state)(self._state)
         self._state = []
-        ver = self._hero.savefile.version
-        cmap = {x.lower(): x for x in metadata.Store.get("spells", version=ver)}
+        cmap = {x.lower(): x for x in metadata.Store.get("spells", self._savefile.version)}
         for i, v in enumerate(state):
             if v and hasattr(v, "lower") and v.lower() in cmap:
                 self._state += [cmap[v.lower()]]
             elif v:
                 logger.warning("Invalid spell #%s: %s", i + 1, v)
         self._state.sort()
         return state0 != self._state
@@ -114,38 +113,41 @@
         """Adds skill at first level."""
         if value in self._state: return False
         self._state.append(value)
         self._state.sort()
         return True
 
 
-    def parse(self, bytes):
-        """Builds spells state from hero bytearray."""
-        result = [] # List of values like ["Haste", ..]
-        IDS = {y: x[y] for x in [metadata.Store.get("ids")]
-               for y in metadata.Store.get("spells")}
+    def parse(self, heroes):
+        """Returns spells states parsed from hero bytearrays, as [[name, ], ]."""
+        result = [] # Lists of values like ["Haste", ..]
+        IDS = {y: x[y] for x in [metadata.Store.get("ids", self._savefile.version)]
+               for y in metadata.Store.get("spells", self._savefile.version)}
         MYPOS = plugins.adapt(self, "pos", POS)
 
-        for name, pos in IDS.items():
-            if bytes[MYPOS["spells_book"] + pos]: result.append(name)
-        self._state[:] = sorted(result)
+        for hero in heroes:
+            values = []
+            for name, pos in IDS.items():
+                if hero.bytes[MYPOS["spells_book"] + pos]: values.append(name)
+            result.append(sorted(values))
+        return result
 
 
     def serialize(self):
         """Returns new hero bytearray, with edited spells sections."""
         result = self._hero.bytes[:]
 
-        IDS = {y: x[y] for x in [metadata.Store.get("ids")]
-               for y in metadata.Store.get("spells")}
+        IDS = {y: x[y] for x in [metadata.Store.get("ids", self._savefile.version)]
+               for y in metadata.Store.get("spells", self._savefile.version)}
         MYPOS = plugins.adapt(self, "pos", POS)
         state = self._state
 
         artispells = set()
         if getattr(self._hero, "artifacts", None):
-            SPELL_ARTIFACTS = metadata.Store.get("artifact_spells")
+            SPELL_ARTIFACTS = metadata.Store.get("artifact_spells", self._savefile.version)
             artispells = set(y for x in self._hero.artifacts.values()
                              for y in SPELL_ARTIFACTS.get(x, []))
         for name, pos in IDS.items():
             in_book   = name in state
             available = in_book or name in artispells
             result[MYPOS["spells_book"] + pos]      = in_book
             result[MYPOS["spells_available"] + pos] = available
```

## h3sed/plugins/hero/stats.py

```diff
@@ -5,15 +5,15 @@
 and war machines.
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   16.03.2020
-@modified  16.01.2022
+@modified  26.02.2023
 ------------------------------------------------------------------------------
 """
 import logging
 
 import wx
 
 from h3sed import gui
@@ -119,58 +119,63 @@
 
 
 def props():
     """Returns props for stats-tab, as {label, index}."""
     return PROPS
 
 
-def factory(parent, hero, panel):
+def factory(savefile, parent, panel):
     """Returns a new stats-plugin instance."""
-    return StatsPlugin(parent, hero, panel)
+    return StatsPlugin(savefile, parent, panel)
 
 
 
 class StatsPlugin(object):
     """Encapsulates stats-plugin state and behaviour."""
 
 
-    def __init__(self, parent, hero, panel):
-        self.name    = PROPS["name"]
-        self.parent  = parent
-        self._hero   = hero
-        self._panel  = panel # Plugin contents panel
-        self._state  = {}    # {attack, defense, ..}
-        if hero:
-            self.parse(hero.bytes)
-            hero.stats = self._state
+    def __init__(self, savefile, parent, panel):
+        self.name      = PROPS["name"]
+        self.parent    = parent
+        self._savefile = savefile
+        self._hero     = None
+        self._panel    = panel  # Plugin contents panel
+        self._state    = {}     # {attack, defense, ..}
 
 
     def props(self):
         """Returns props for stats-tab, as [{type: "number", ..}]."""
         result = []
-        IDS = metadata.Store.get("ids")
+        IDS = metadata.Store.get("ids", self._savefile.version)
         for prop in UIPROPS:
             if "value" in prop: prop = dict(prop, value=IDS[prop["label"]])
             result.append(prop)
         return plugins.adapt(self, "props", result)
 
 
     def state(self):
         """Returns data state for stats-plugin, as {mana, exp, ..}."""
         return plugins.adapt(self, "state", self._state)
 
 
+    def item(self):
+        """Returns current hero."""
+        return self._hero
+
+
     def load(self, hero, panel=None):
         """Loads hero to plugin."""
         self._hero = hero
         self._state.clear()
         if panel: self._panel = panel
         if hero:
-            self.parse(hero.bytes)
+            self._state.clear()
+            self._state.update(self.parse([hero])[0])
             hero.stats = self._state
+            hero.ensure_basestats()
 
 
     def load_state(self, state):
         """Loads plugin state from given data, ignoring unknown values. Returns whether state changed."""
         state0 = type(self._state)(self._state)
         for prop in self.props():
             if prop["name"] not in state:
@@ -183,61 +188,61 @@
             else:
                 logger.warning("Invalid stats item %r: %r", prop["name"], v)
         return state0 != self._state
 
 
     def on_change(self, prop, row, ctrl, value):
         """
-        Handler for artifact slot change, updates state,
-        and hero stats if old or new artifact affects primary skills.
-        Rolls back change if lacking free slot due to a combination artifact.
-        Returns whether action succeeded.
+        Handler for stats change, updates state, notifies other plugins if spellbook was toggled.
+        Returns whether anything changed in stats.
         """
         v2, v1 = None if value == "" else value, self._state[prop["name"]]
         if v2 == v1: return False
 
         self._state[prop["name"]] = v2
 
+        if prop["name"] in self._hero.basestats:
+            self._hero.basestats[prop["name"]] += v2 - v1
         if "spellbook" == prop["name"]:
             evt = gui.PluginEvent(self._panel.Id, action="render", name="spells")
             wx.PostEvent(self._panel, evt)
         return True
 
 
-
-    def parse(self, bytes):
-        """Builds stats state from hero bytearray."""
-        result = {}
-
-        NAMES = {x[y]: y for x in [metadata.Store.get("ids")]
-                 for y in metadata.Store.get("special_artifacts")}
+    def parse(self, heroes):
+        """Returns stats states parsed from hero bytearrays, as [{attack, defense, ..}, ]."""
+        result = []
+        NAMES = {x[y]: y for x in [metadata.Store.get("ids", self._savefile.version)]
+                 for y in metadata.Store.get("special_artifacts", self._savefile.version)}
         MYPOS = plugins.adapt(self, "pos", POS)
 
-        def parse_special(pos):
-            b, v = bytes[pos:pos + 4], util.bytoi(bytes[pos:pos + 4])
+        def parse_special(hero, pos):
+            b, v = hero.bytes[pos:pos + 4], util.bytoi(hero.bytes[pos:pos + 4])
             return None if all(x == ord(metadata.Blank) for x in b) else v
 
-        for prop in self.props():
-            pos = MYPOS[prop["name"]]
-            if "check" == prop["type"]:
-                v = parse_special(pos) is not None
-            elif "number" == prop["type"]:
-                v = util.bytoi(bytes[pos:pos + prop["len"]])
-            elif "combo" == prop["type"]:
-                v = NAMES.get(parse_special(pos), "")
-            result[prop["name"]] = v
-
-        self._state.clear(); self._state.update(result)
+        for hero in heroes:
+            values = {}
+            for prop in self.props():
+                pos = MYPOS[prop["name"]]
+                if "check" == prop["type"]:
+                    v = parse_special(hero, pos) is not None
+                elif "number" == prop["type"]:
+                    v = util.bytoi(hero.bytes[pos:pos + prop["len"]])
+                elif "combo" == prop["type"]:
+                    v = NAMES.get(parse_special(hero, pos), "")
+                values[prop["name"]] = v
+            result.append(values)
+        return result
 
 
     def serialize(self):
         """Returns new hero bytearray, with edited stats sections."""
         result = self._hero.bytes[:]
 
-        IDS = metadata.Store.get("ids")
+        IDS = metadata.Store.get("ids", self._savefile.version)
         MYPOS = plugins.adapt(self, "pos", POS)
 
         for prop in self.props():
             v, pos = self._state[prop["name"]], MYPOS[prop["name"]]
             if "check" == prop["type"]:
                 b = (util.itoby(prop["value"], 4) if v else metadata.Blank * 4)
                 b = b[:4] + result[pos + 4:pos + 8]
```

## h3sed/plugins/version/hota.py

```diff
@@ -3,15 +3,15 @@
 Subplugin for HOMM3 version "Horn of the Abyss".
 
 ------------------------------------------------------------------------------
 This file is part of h3sed - Heroes3 Savegame Editor.
 Released under the MIT License.
 
 @created   22.03.2020
-@modified  16.01.2022
+@modified  09.02.2023
 ------------------------------------------------------------------------------
 """
 import logging
 import re
 
 from h3sed.lib import util
 from h3sed.metadata import Store
@@ -269,28 +269,29 @@
 
     .{63}                    #  63 bytes: unknown                              019-081
 
     .{28}                    #  28 bytes: 7 4-byte creature IDs                082-109
     .{28}                    #  28 bytes: 7 4-byte creature counts             110-137
 
                              #  13 bytes: hero name, null-padded               138-150
-    (?P<name>[^\x00-\x20,\xF0-\xFF].{12})
+    (?P<name>[^\x00-\x20,\xF0-\xFF].{11}\x00)
     [\x00-\x03]{29}          #  29 bytes: skill levels (Interference last)     151-179
     .{27}                    #  27 bytes: skill slots (legacy, unused)         180-206
     .{4}                     #   4 bytes: primary stats                        207-210
 
     [\x00-\x01]{70}          #  70 bytes: spells book                          211-280
     [\x00-\x01]{70}          #  70 bytes: spells available                     281-350
 
                              # 152 bytes: 19 8-byte equipments worn            351-502
-                             # Blank spots:   FF FF FF FF 00 00 00 00
+                             # Blank spots:   FF FF FF FF XY XY XY XY
                              # Artifacts:     XY 00 00 00 FF FF FF FF
                              # Scrolls:       XY 00 00 00 00 00 00 00
-                             # Catapult etc:  XY 00 00 00 XY XY 00 00
-    ( ((.\x00{3}) | \xFF{4}) (\x00{4} | \xFF{4} | (.{2}\x00{2})) ){19}
+    (?P<artifacts>           # Catapult etc:  XY 00 00 00 XY XY 00 00
+      (\xFF{4} .{4}) | (.\x00{3} (\x00{4} | \xFF{4})) | (.\x00{3}.{2}\x00{2})
+    ){19}
 
                              # 512 bytes: 64 8-byte artifacts in backpack      503-1014
     ( ((.\x00{3}) | \xFF{4}) (\x00{4} | \xFF{4}) ){64}
 
                              # 10 bytes: slots taken by combination artifacts 1015-1024
     .[\x00-\x01]{6}[\x00-\x02][\x00-\x01][\x00-\x05]
```

## Comparing `h3sed-1.0.dist-info/LICENSE.md` & `h3sed-1.6.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `h3sed-1.0.dist-info/METADATA` & `h3sed-1.6.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: h3sed
-Version: 1.0
+Version: 1.6
 Summary: Heroes3 Savegame Editor
 Home-page: https://github.com/suurjaak/h3sed
 Author: Erki Suurjaak
 Author-email: erki@lap.ee
 License: MIT
 Keywords: homm homm3 heroes3 savegame
 Platform: any
@@ -26,52 +26,56 @@
 
 h3sed
 =====
 
 h3sed is a Heroes3 Savegame Editor, written in Python.
 
 It opens savegame files from Heroes of Might and Magic III,
-allowing to edit any and all hero attributes:
+allowing to see an overview of all heroes, and edit any and all hero attributes:
 
 - primary skills, like Attack
 - other primary attributes, like level, experience points, spell points etc
 - war machines, like Ballista
 - secondary skills, like Logistics (more than 8 skills can be added)
 - artifacts, like Boots of Speed, both worn and inventory items
 - spells, like Slow
 - army creatures, like Golden Dragons
 
 Attributes can be copied from one hero and pasted to another.
 
 Supports savegames from Shadow of Death and Horn of the Abyss.
 
-Downloads at http://suurjaak.github.io/h3sed.
+Downloads at https://suurjaak.github.io/h3sed.
 
 
 Usage
 -----
 
-Navigate the file view to Heroes3 games-folder, and open a savegame file to edit.
+Navigate the file view to Heroes3 games-folder and open a savegame file to edit,
+or drag and drop a savegame file onto the program window.
 
 Choose a hero to modify, change attributes to your liking, and save the file.
 Changes will be available in Heroes3 after loading the changed savegame.
 
 Attributes from one hero can be copied to clipboard as text,
 and pasted onto another hero, overwriting their data.
 
-A timestamped backup copy is automatically created of the savegame file.
+A timestamped daily backup copy is automatically created of the savegame file.
 
-![Screenshot](https://raw.githubusercontent.com/suurjaak/h3sed/media/screen.png)
+![Screenshot](https://raw.githubusercontent.com/suurjaak/h3sed/gh-pages/img/screen.png)
 
 **Warning:** as Heroes3 savefile format is not publicly known,
 loaded data and saved results may be invalid and cause problems in game.
 This program is based on unofficial information
 gathered from observation and online forums.
 
-Always choose the correct game version. A wrong choice will result
+The savegames of Shadow of Death and Horn of the Abyss are not mutually
+compatible. The program tries to auto-detect the version heuristically,
+but this detection does not guarantee a correct result.
+Always ensure the correct game version being selected. A wrong choice will result
 in file data being misinterpreted, and saving later version items
 or creatures to an earlier version savefile may cause the game to crash.
 
 
 Installation
 ------------
 
@@ -91,15 +95,15 @@
 If running straight from source code, open a terminal to `h3sed/src`
 and run `python -m h3sed`.
 
 
 Source Dependencies
 -------------------
 
-If running from source code, h3sed needs Python 2.7 or higher,
+If running from source code, h3sed needs Python 2.7 or Python 3.6 or higher,
 and the following 3rd-party Python packages:
 * pyyaml (https://pyyaml.org)
 * wxPython 4.0+ (https://wxpython.org)
 
 
 Attribution
 -----------
```

## Comparing `h3sed-1.0.dist-info/RECORD` & `h3sed-1.6.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,33 +1,33 @@
 h3sed/__init__.py,sha256=mgWnKo3Y6AQUI6FMaFYghlhhUEWw_8O4e-aF8bs1uvk,76
 h3sed/__main__.py,sha256=dLLEHzSyAMiFo7-zsAQhqzR2nvoiC23WKBBUCuuHl_4,94
-h3sed/conf.py,sha256=Qtezhj9G9461c1rxQwwTiqtlXcPa0ESEXAXkvO4iLhk,7015
-h3sed/gui.py,sha256=kSykwKA6hnZSN-cPQelNnbj91IJ3LNQvN0VvMlnn6kg,61164
+h3sed/conf.py,sha256=hujkGMwZNOMWbcNaTkGHhY2ucRnmazFKa90booffH4M,7364
+h3sed/gui.py,sha256=EVch8b2-WBCkdaF2XpPRnhJXaX1HXfE2kmIqafM9nJU,67997
 h3sed/guibase.py,sha256=oWoD40pNuG5mlaLakJoaDbYitgLW3rxGKOf2eOW_kKQ,10896
-h3sed/images.py,sha256=16gmJm3-opEEwgDeyvopI7X1b3iNtSqp78fDGu3msxk,15365
-h3sed/main.py,sha256=Uh8STyCXmC6ZYBuMVsuwYyoF-a_bKa7EK_ffAatI3R0,5346
-h3sed/metadata.py,sha256=OZR1PF8cvwZ9LNtR2pIJoE5qDvXrNYQeU1STNxdL6ck,41442
-h3sed/templates.py,sha256=rOva4aLoYUlL1Y25eHhnmicJnyAj7p9O0os186HjkZc,2796
-h3sed/etc/h3sed.ini,sha256=k_RoG7H2ncQSnrcNUDE85_KBiZHDg6_rRL6meHRpTsw,263
+h3sed/images.py,sha256=CdloD0Pfpc0zDxfA8emcs-P4WgIeIlLD_YFCQQeOK7A,41483
+h3sed/main.py,sha256=R3Ns6kRhquSem_iiFdTuX7DltW8iQnUV_07D43bZCRM,5800
+h3sed/metadata.py,sha256=qRDge-Hb7rtUdzWCAjA2ToVH3QYzxKj036oAEwW5alY,41558
+h3sed/templates.py,sha256=oY3Ga20_TUM0JUIdfmslusf__AVVg3sKR4p9m9YUB18,25247
+h3sed/etc/h3sed.ini,sha256=yOxBx-wDv4fGOk3T1L3Qmtu3WawOVgVtnGcqZlrZgdk,276
 h3sed/lib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-h3sed/lib/controls.py,sha256=QiU3WchC4f6hlvSwwbYULMc2QTItqfj2qH9W10R4Jjk,9543
-h3sed/lib/util.py,sha256=2zDDbA1w7QASsrqyvtG98-Lf1MZt1R9vUhnKnCuOspg,11589
+h3sed/lib/controls.py,sha256=v0hXQxJBlGY6ZukPIiJ1P0wKVDIrVGZRkaC434uFOrI,23257
+h3sed/lib/util.py,sha256=Oz_VDlXVAQDyvAjGo5kU6WtEm3Qxl-OKzOfTATDLhuI,13977
 h3sed/lib/wx_accel.py,sha256=hwsUKEj032eKAFSB6JyUhpgS_mnUZ7dY_96RwhKCDho,17561
 h3sed/lib/vendor/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-h3sed/lib/vendor/step.py,sha256=00A0GmX9z5sOmTKfAJa3zkk8eItyb7S0sS-iS-oi_Vs,7396
-h3sed/plugins/__init__.py,sha256=ogBTCqj7MUYA1NEMrN29uGFH3Trf5a6Dra0EnUZzpsw,5846
-h3sed/plugins/hero/__init__.py,sha256=iRVsaAWNAgpv82x1FqvLVmkxGonIw9lMFjNeJZ1zoMU,25434
-h3sed/plugins/hero/army.py,sha256=ERcoUmPqkxAWxxIt4yUlgQ8Y_elAGkO99Mp0R955u9M,8806
-h3sed/plugins/hero/artifacts.py,sha256=DKJu9nBYtEPo5I6Q36sgBCH7jdK5PRll_qtkqTlewqM,13370
-h3sed/plugins/hero/inventory.py,sha256=AfsMVZflY_MfukZKurgmfs6O6Ze2hSFJCx_AQFgBBCY,5877
-h3sed/plugins/hero/skills.py,sha256=P6xIjXyxMoap59LzWO0eP7GMl_6fRbjhf-SMNvf3kgc,6577
-h3sed/plugins/hero/spells.py,sha256=iRgRVOK2bIUSxHiLKfKT-EXkjmcT8E5sw0MMEvM6zJE,4816
-h3sed/plugins/hero/stats.py,sha256=gOSnTmK4clv4wPMBOxt3NK5FKJYj7frfebAf5syErDw,7719
+h3sed/lib/vendor/step.py,sha256=zSQEU-j9mdrc8gdSqQ82tQCwxK7p5KJ431DuI1jmXfs,7446
+h3sed/plugins/__init__.py,sha256=0zQP2Cs1bVdcp8LETZwaC3q-RTNF49hSVGdNsxBRa4Q,6064
+h3sed/plugins/hero/__init__.py,sha256=5LAHkm6wURDy5HGqZJ3XNmGe_b139LO0a_Sqccxt-dQ,51648
+h3sed/plugins/hero/army.py,sha256=ATzmJPwmxp8S0MmcmtUEHLqqICp7cKbVJEAzAsiNZrU,9604
+h3sed/plugins/hero/artifacts.py,sha256=g3_tlqgVv_f8MJnL4LGc_XSmZuNwbNvpsGNOUjqDhCk,14628
+h3sed/plugins/hero/inventory.py,sha256=W2jumY6Dcna5KmfotTNiNs1q6AzSzRfuX9a5ToHMzVw,6135
+h3sed/plugins/hero/skills.py,sha256=vRgKXjOx1DibJXdmnpo-MJxjI_6EI2_zlpAVn2KM_Oc,7174
+h3sed/plugins/hero/spells.py,sha256=yS6MiQh08szFpSW2XPhXmGcKSmmdKD5PcAQq0PjhDnU,5001
+h3sed/plugins/hero/stats.py,sha256=6Ps8ad1wmpa-50ZSxOVnAH3_CKbQhMGEkQa9OPxDWGI,8128
 h3sed/plugins/version/__init__.py,sha256=MoqEg3XQ2OghUWvrWUXdjNsUPtO3VdP2y5lC0UGD3Tc,2110
-h3sed/plugins/version/hota.py,sha256=oK2dJvk4O_OySpVo6teannAeObXT8CWb5WrQxyDPB9w,14474
+h3sed/plugins/version/hota.py,sha256=Piy8eM_5SF8-8gEGhIeJ7IFThIpj4kGjSgeicunylwA,14496
 h3sed/plugins/version/sod.py,sha256=4t2OTeQCCXAVBs5WiM-KVQgeXSr3cDt4UWNiCKuF85I,6282
-h3sed-1.0.dist-info/LICENSE.md,sha256=8YjDZM6LRG87mXfw2KYhdbWHuR-wvwOGi4D1y9Qghm0,1100
-h3sed-1.0.dist-info/METADATA,sha256=K0r03fndFFoRSijCzZrZ2vMJ5ZHNnUSVM0019rMTIQs,4220
-h3sed-1.0.dist-info/WHEEL,sha256=6T3TYZE4YFi2HTS1BeZHNXAi8N52OZT4O-dJ6-ome_4,116
-h3sed-1.0.dist-info/entry_points.txt,sha256=VFSXODV63gJum67az4DOmc27ktcp4tzEt7AJIumQFkc,38
-h3sed-1.0.dist-info/top_level.txt,sha256=9IbalHA56Rhkznc6o4tVTefe9tS6jw8SMFy9gOrFJE4,6
-h3sed-1.0.dist-info/RECORD,,
+h3sed-1.6.dist-info/LICENSE.md,sha256=8YjDZM6LRG87mXfw2KYhdbWHuR-wvwOGi4D1y9Qghm0,1100
+h3sed-1.6.dist-info/METADATA,sha256=voiTwSEFxkBmRPN0amuQw8xL18o_6IUCvcYUq6bw0Go,4559
+h3sed-1.6.dist-info/WHEEL,sha256=umevUEtYglx3BsmRdkbeexA0ajsvOK25YhJUBycYWFg,97
+h3sed-1.6.dist-info/entry_points.txt,sha256=VFSXODV63gJum67az4DOmc27ktcp4tzEt7AJIumQFkc,38
+h3sed-1.6.dist-info/top_level.txt,sha256=9IbalHA56Rhkznc6o4tVTefe9tS6jw8SMFy9gOrFJE4,6
+h3sed-1.6.dist-info/RECORD,,
```

